// ==UserScript==
// @name          ctop
// @namespace     http://w3c.org/Math
// @description   ctop
// @include       http://www.w3.org/Math/testsuite/*
// @include       http://www.w3.org/TR/MathML/*
// ==/UserScript==

var xslt = new DOMParser().parseFromString('<x:stylesheet version="1.0" xmlns:x="http://www.w3.org/1999/XSL/Transform" xmlns:m="http://www.w3.org/1998/Math/MathML">  <!--  Copyright David Carlisle 2001, 2002, 2008, 2009.  Use and distribution of this code are permitted under the terms of the<a href="http://www.w3.org/Consortium/Legal/copyright-software-19980720" >W3C Software Notice and License</a>. 2001-2002 MathML2 version 2008-2009     Updates for MathML3 --> <x:output method="xml" /> <x:template match="/"><x:apply-templates/></x:template> <x:template match="*"><x:copy><x:copy-of select="@*"/><x:apply-templates/></x:copy></x:template>    <x:template match="m:cn"><m:mn><x:apply-templates/></m:mn></x:template> <x:template match="m:cn[@type=\'complex-cartesian\']"><m:mrow><m:mn><x:apply-templates select="text()[1]"/></m:mn><m:mo>+</m:mo><m:mn><x:apply-templates select="text()[2]"/></m:mn><m:mo>&#8290;</m:mo><m:mi>i</m:mi></m:mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'complex_cartesian\']]"><m:mrow><m:mn><x:apply-templates select="*[2]"/></m:mn><m:mo>+</m:mo><m:mn><x:apply-templates select="*[3]"/></m:mn><m:mo>&#8290;</m:mo><m:mi>i</m:mi></m:mrow></x:template> <x:template match="m:cn[@type=\'rational\']"><m:mrow><m:mn><x:apply-templates select="text()[1]"/></m:mn><m:mo>/</m:mo><m:mn><x:apply-templates select="text()[2]"/></m:mn></m:mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'rational\']]"><m:mrow><m:mn><x:apply-templates select="*[2]"/></m:mn><m:mo>/</m:mo><m:mn><x:apply-templates select="*[3]"/></m:mn></m:mrow></x:template> <x:template match="m:cn[not(@type) or @type=\'integer\']"><x:choose><x:when test="not(@base) or @base=10"><m:mn><x:apply-templates/></m:mn></x:when><x:otherwise><m:msub><m:mn><x:apply-templates/></m:mn><m:mn><x:value-of select="@base"/></m:mn></m:msub></x:otherwise></x:choose></x:template> <x:template match="m:cn[@type=\'complex-polar\']"><m:mrow><m:mn><x:apply-templates select="text()[1]"/></m:mn><m:mo>&#8290;</m:mo><m:msup><m:mi>e</m:mi><m:mrow><m:mi>i</m:mi><m:mo>&#8290;</m:mo><m:mn><x:apply-templates select="text()[2]"/></m:mn></m:mrow></m:msup></m:mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'complex_polar\']]"><m:mrow><x:apply-templates select="*[2]"/><m:mo>&#8290;</m:mo><m:msup><m:mi>e</m:mi><m:mrow><m:mi>i</m:mi><m:mo>&#8290;</m:mo><x:apply-templates select="*[3]"/></m:mrow></m:msup></m:mrow></x:template> <x:template match="m:cn[@type=\'e-notation\']"><m:mn><x:apply-templates select="m:sep/preceding-sibling::node()"/><x:text>E</x:text><x:apply-templates select="m:sep/following-sibling::node()"/></m:mn></x:template> <x:template match="m:cn[@type=\'hexdouble\']"><m:mn><x:text>0x</x:text><x:apply-templates/></m:mn></x:template>   <x:template match="m:ci/text()"><m:mi><x:value-of select="."/></m:mi></x:template> <x:template match="m:ci"><m:mrow><x:apply-templates/></m:mrow></x:template>   <x:template match="m:csymbol/text()"><m:mi><x:value-of select="."/></m:mi></x:template> <x:template match="m:csymbol"><m:mrow><x:apply-templates/></m:mrow></x:template>   <x:template match="m:apply|m:reln"><m:mrow><x:choose><x:when test="*[1]/*/*"><m:mfenced separators="">	<x:apply-templates select="*[1]">	<x:with-param name="p" select="10"/>	</x:apply-templates></m:mfenced></x:when><x:otherwise><x:apply-templates select="*[1]">	<x:with-param name="p" select="10"/></x:apply-templates></x:otherwise></x:choose><m:mo>&#8289;</m:mo><m:mfenced open="(" close=")" separators=","><x:apply-templates select="*[position()>1]"/></m:mfenced></m:mrow></x:template>  <x:template match="m:bind"><m:mrow><x:choose><x:when test="*[1]/*/*"><m:mfenced separators="">	<x:apply-templates select="*[1]">	<x:with-param name="p" select="10"/>	</x:apply-templates></m:mfenced></x:when><x:otherwise><x:apply-templates select="*[1]">	<x:with-param name="p" select="10"/></x:apply-templates></x:otherwise></x:choose><x:apply-templates select="bvar/*"/><m:mo>.</m:mo><x:apply-templates select="*[position()>1][not(self::m:bvar)]"/></m:mrow></x:template>  <x:template match="m:fn"><m:mrow><x:apply-templates/></m:mrow></x:template>  <x:template match="m:interval[*[2]]"><m:mfenced open="[" close="]"><x:apply-templates/></m:mfenced></x:template><x:template match="m:interval[*[2]][@closure=\'open\']" priority="2"><m:mfenced open="(" close=")"><x:apply-templates/></m:mfenced></x:template><x:template match="m:interval[*[2]][@closure=\'open-closed\']" priority="2"><m:mfenced open="(" close="]"><x:apply-templates/></m:mfenced></x:template><x:template match="m:interval[*[2]][@closure=\'closed-open\']" priority="2"><m:mfenced open="[" close=")"><x:apply-templates/></m:mfenced></x:template> <x:template match="m:interval"><m:mfenced open="{{" close="}}"><x:apply-templates/></m:mfenced></x:template>   <x:template match="m:apply[*[1][self::m:inverse]]                        |m:apply[*[1][self::m:csymbol=\'inverse\']]"><m:msup><x:apply-templates select="*[2]"/><m:mrow><m:mo>(</m:mo><m:mn>-1</m:mn><m:mo>)</m:mo></m:mrow></m:msup></x:template>    <x:template match="m:condition"><m:mrow><x:apply-templates/></m:mrow></x:template>  <x:template match="m:declare"/>  <x:template match="m:lambda 				|m:apply[*[1][self::m:csymbol=\'lambda\']] 				|m:bind[*[1][self::m:csymbol=\'lambda\']]"><m:mrow><m:mi>&#955;</m:mi><m:mrow><x:apply-templates select="m:bvar/*"/></m:mrow><m:mo>.</m:mo><m:mfenced><x:apply-templates select="*[last()]"/></m:mfenced></m:mrow></x:template>   <x:template match="m:apply[*[1][self::m:compose]]                        |m:apply[*[1][self::m:csymbol=\'left_compose\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8728;</m:mo></x:with-param></x:call-template></x:template>   <x:template match="m:ident"><m:mi>id</m:mi></x:template>  <x:template match="m:domain"><m:mi>domain</m:mi></x:template>  <x:template match="m:codomain"><m:mi>codomain</m:mi></x:template>  <x:template match="m:image"><m:mi>image</m:mi></x:template>  <x:template match="m:domainofapplication"><m:merror><m:mtext>unexpected domainofapplication</m:mtext></m:merror></x:template>  <x:template match="m:piecewise"><m:mrow><m:mo>{</m:mo><m:mtable><x:for-each select="m:piece|m:otherwise">	<m:mtr>	<m:mtd><x:apply-templates select="*[1]"/></m:mtd>	<x:choose>	<x:when  test="self::m:piece">	<m:mtd columnalign="left"><m:mtext>&#160; if &#160;</m:mtext></m:mtd>	<m:mtd><x:apply-templates select="*[2]"/></m:mtd>	</x:when>	<x:otherwise>	<m:mtd colspan="2" columnalign="left"><m:mtext>&#160; otherwise</m:mtext></m:mtd>	</x:otherwise>	</x:choose>	</m:mtr></x:for-each></m:mtable></m:mrow></x:template>   <x:template match="m:apply[*[1][self::m:quotient]]                        |m:apply[*[1][self::m:csymbol=\'quotient\']]"><m:mrow><m:mo>&#8970;</m:mo><x:apply-templates select="*[2]"/><m:mo>/</m:mo><x:apply-templates select="*[3]"/><m:mo>&#8971;</m:mo></m:mrow></x:template>    <x:template match="m:apply[*[1][self::m:factorial]] 				|m:apply[*[1][self::m:csymbol=\'factorial\']]"><m:mrow><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates><m:mo>!</m:mo></m:mrow></x:template>   <x:template match="m:apply[*[1][self::m:divide]] 				|m:apply[*[1][self::m:csymbol=\'divide\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><m:mo>/</m:mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:max]] 				|m:apply[*[1][self::m:csymbol=\'max\']]"><m:mrow><m:mi>max</m:mi><x:call-template name="set"/></m:mrow></x:template> <x:template match="m:apply[*[1][self::m:min]]|m:reln[*[1][self::m:min]]"><m:mrow><m:mi>min</m:mi><x:call-template name="set"/></m:mrow></x:template>  <x:template match="m:apply[*[1][self::m:minus] and count(*)=2] 				|m:apply[*[1][self::m:csymbol=\'unary_minus\']]"><m:mrow><m:mo>&#8722;</m:mo><x:apply-templates select="*[2]"><x:with-param name="p" select="5"/></x:apply-templates></m:mrow></x:template> <x:template match="m:apply[*[1][self::m:minus] and count(*)&gt;2] 				|m:apply[*[1][self::m:csymbol=\'minus\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><m:mo>&#8722;</m:mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="2"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:plus]] 				|m:apply[*[1][self::m:csymbol=\'plus\']]"><x:param name="p" select="0"/><m:mrow><x:if test="$p &gt; 2"><m:mo>(</m:mo></x:if><x:for-each select="*[position()&gt;1]"><x:if test="position() &gt; 1"><m:mo><x:choose><x:when test="self::m:apply[*[1][self::m:times] and       *[2][self::m:apply/*[1][self::m:minus] or self::m:cn[not(m:sep) and       (number(.) &lt; 0)]]]">&#8722;</x:when><x:otherwise>+</x:otherwise></x:choose></m:mo></x:if><x:choose><x:when test="self::m:apply[*[1][self::m:times] and       *[2][self::m:cn[not(m:sep) and (number(.) &lt;0)]]]"><m:mrow><m:mn><x:value-of select="-(*[2])"/></m:mn><m:mo>&#8290;</m:mo><x:apply-templates select="."><x:with-param name="first" select="2"/><x:with-param name="p" select="2"/></x:apply-templates></m:mrow></x:when><x:when test="self::m:apply[*[1][self::m:times] and       *[2][self::m:apply/*[1][self::m:minus]]]"><m:mrow><x:apply-templates select="./*[2]/*[2]"/><x:apply-templates select="."><x:with-param name="first" select="2"/><x:with-param name="p" select="2"/></x:apply-templates></m:mrow></x:when><x:otherwise><x:apply-templates select="."><x:with-param name="p" select="2"/></x:apply-templates></x:otherwise></x:choose></x:for-each><x:if test="$p &gt; 2"><m:mo>)</m:mo></x:if></m:mrow></x:template>   <x:template match="m:apply[*[1][self::m:power]] 				|m:apply[*[1][self::m:csymbol=\'power\']]"><m:msup><x:apply-templates select="*[2]"><x:with-param name="p" select="5"/></x:apply-templates><x:apply-templates select="*[3]"><x:with-param name="p" select="5"/></x:apply-templates></m:msup></x:template>  <x:template match="m:apply[*[1][self::m:rem]]                        |m:apply[*[1][self::m:csymbol=\'rem\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><m:mo>mod</m:mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:times]] 				|m:apply[*[1][self::m:csymbol=\'times\']]" 	      name="times"><x:param name="p" select="0"/><x:param name="first" select="1"/><m:mrow><x:if test="$p &gt; 3"><m:mo>(</m:mo></x:if><x:for-each select="*[position()&gt;1]"><x:if test="position() &gt; 1"><m:mo><x:choose><x:when test="self::m:cn">&#215;</x:when><x:otherwise>&#8290;</x:otherwise></x:choose></m:mo></x:if><x:if test="position()&gt;= $first"><x:apply-templates select="."><x:with-param name="p" select="3"/></x:apply-templates></x:if></x:for-each><x:if test="$p &gt; 3"><m:mo>)</m:mo></x:if></m:mrow></x:template>   <x:template match="m:apply[*[1][self::m:root] and not(m:degree) or m:degree=2]" priority="4"><m:msqrt><x:apply-templates select="*[position()&gt;1]"/></m:msqrt></x:template> <x:template match="m:apply[*[1][self::m:root]]"><m:mroot><x:apply-templates select="*[position()&gt;1 and not(self::m:degree)]"/><m:mrow><x:apply-templates select="m:degree/*"/></m:mrow></m:mroot></x:template>  <x:template match="m:apply[*[1][self::m:csymbol=\'root\']]"><m:mroot><x:apply-templates select="*[position()!=1]"/></m:mroot></x:template>  <x:template match="m:gcd"><m:mi>gcd</m:mi></x:template>  <x:template match="m:apply[*[1][self::m:and]] 				|m:reln[*[1][self::m:and]] 				|m:apply[*[1][self::m:csymbol=\'and\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8743;</m:mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:or]]                        |m:apply[*[1][self::m:csymbol=\'or\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="3"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8744;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:xor]]                        |m:apply[*[1][self::m:csymbol=\'xor\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="3"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>xor</m:mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:not]]                        |m:apply[*[1][self::m:csymbol=\'not\']]"><m:mrow><m:mo>&#172;</m:mo><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates></m:mrow></x:template>     <x:template match="m:apply[*[1][self::m:implies]] 				|m:reln[*[1][self::m:implies]] 				|m:apply[*[1][self::m:csymbol=\'implies\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><m:mo>&#8658;</m:mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:forall]]                        |m:apply[*[1][self::m:csymbol=\'forall\']]                        |m:bind[*[1][self::m:forall]]                        |m:bind[*[1][self::m:csymbol=\'forall\']]"><m:mrow><m:mo>&#8704;</m:mo><m:mrow><x:apply-templates select="m:bvar[not(current()/m:condition)]/*|m:condition/*"/></m:mrow><m:mo>.</m:mo><m:mfenced><x:apply-templates select="*[last()]"/></m:mfenced></m:mrow></x:template>    <x:template match="m:apply[*[1][self::m:exists]]                        |m:apply[*[1][self::m:csymbol=\'exists\']]                        |m:bind[*[1][self::m:exists]]                        |m:bind[*[1][self::m:csymbol=\'exists\']]"><m:mrow><m:mo>&#8707;</m:mo><m:mrow><x:apply-templates select="m:bvar[not(current()/m:condition)]/*|m:condition/*"/></m:mrow><m:mo>.</m:mo><m:mfenced separators=""><x:choose><x:when test="m:condition"><x:apply-templates select="m:condition/*"/><m:mo>&#8743;</m:mo></x:when><x:when test="m:domainofapplication"><m:mrow><m:mrow>	<x:for-each select="m:bvar">	<x:apply-templates/>	<x:if test="position()!=last()">	<m:mo>,</m:mo>	</x:if>	</x:for-each></m:mrow><m:mo>&#8712;</m:mo><x:apply-templates select="m:domainofapplication/*"/></m:mrow><m:mo>&#8743;</m:mo></x:when></x:choose><x:apply-templates select="*[last()]"/></m:mfenced></m:mrow></x:template>    <x:template match="m:apply[*[1][self::m:abs]]                        |m:apply[*[1][self::m:csymbol=\'abs\']]"><m:mrow><m:mo>|</m:mo><x:apply-templates select="*[2]"/><m:mo>|</m:mo></m:mrow></x:template>    <x:template match="m:apply[*[1][self::m:conjugate]]                        |m:apply[*[1][self::m:csymbol=\'conjugate\']]"><m:mover><x:apply-templates select="*[2]"/><m:mo>&#175;</m:mo></m:mover></x:template>  <x:template match="m:arg"><m:mi>arg</m:mi></x:template>   <x:template match="m:real|m:csymbol[.=\'real\']"><m:mo>&#8475;</m:mo></x:template>  <x:template match="m:imaginary|m:csymbol[.=\'imaginary\']"><m:mo>&#8465;</m:mo></x:template>  <x:template match="m:lcm"><m:mi>lcm</m:mi></x:template>   <x:template match="m:apply[*[1][self::m:floor]]                        |m:apply[*[1][self::m:csymbol=\'floor\']]"><m:mrow><m:mo>&#8970;</m:mo><x:apply-templates select="*[2]"/><m:mo>&#8971;</m:mo></m:mrow></x:template>   <x:template match="m:apply[*[1][self::m:ceiling]]                        |m:apply[*[1][self::m:csymbol=\'ceiling\']]"><m:mrow><m:mo>&#8968;</m:mo><x:apply-templates select="*[2]"/><m:mo>&#8969;</m:mo></m:mrow></x:template>  <x:template match="m:apply[*[1][self::m:eq]] 				|m:reln[*[1][self::m:eq]] 				|m:apply[*[1][self::m:csymbol=\'eq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>=</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:neq]]                        |m:apply[*[1][self::m:csymbol=\'neq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8800;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:gt]] 				|m:reln[*[1][self::m:gt]] 				|m:apply[*[1][self::m:csymbol=\'gt\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&gt;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:lt]] 				|m:reln[*[1][self::m:lt]] 				|m:apply[*[1][self::m:csymbol=\'lt\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&lt;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:geq]] 				|m:apply[*[1][self::m:csymbol=\'geq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8805;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:leq]]                        |m:apply[*[1][self::m:csymbol=\'leq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8804;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:equivalent]]                        |m:apply[*[1][self::m:csymbol=\'equivalent\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8801;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:approx]]                        |m:apply[*[1][self::m:csymbol=\'approx\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8771;</m:mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:factorof]]                        |m:apply[*[1][self::m:csymbol=\'factorof\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><m:mo>|</m:mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:int]]                        |m:apply[*[1][self::m:csymbol=\'int\']]                        |m:bind[*[1][self::m:csymbol=\'int\']]"><m:mrow><m:msubsup><m:mi>&#8747;</m:mi><m:mrow><x:apply-templates select="m:lowlimit/*|m:interval/*[1]|m:condition/*|m:domainofapplication/*"/></m:mrow><m:mrow><x:apply-templates select="m:uplimit/*|m:interval/*[2]"/></m:mrow></m:msubsup><x:apply-templates select="*[last()]"/><x:if test="m:bvar"><m:mi>d</m:mi><x:apply-templates select="m:bvar"/></x:if></m:mrow></x:template>  <x:template match="m:apply[*[1][self::m:diff] and not(m:bvar)]" priority="2"><m:msup><m:mrow><x:apply-templates select="*[2]"/></m:mrow><m:mo>&#8242;</m:mo></m:msup></x:template> <x:template match="m:apply[*[1][self::m:diff]]" priority="1"><m:mfrac><x:choose><x:when test="m:bvar/m:degree"><m:mrow><m:msup><m:mi>d</m:mi><x:apply-templates select="m:bvar/m:degree/node()"/></m:msup><x:apply-templates  select="*[last()]"/></m:mrow><m:mrow><m:mi>d</m:mi><m:msup><x:apply-templates  select="m:bvar/node()"/><x:apply-templates  select="m:bvar/m:degree/node()"/></m:msup></m:mrow></x:when><x:otherwise><m:mrow><m:mi>d</m:mi><x:apply-templates select="*[last()]"/></m:mrow><m:mrow><m:mi>d</m:mi><x:apply-templates select="m:bvar"/></m:mrow></x:otherwise></x:choose></m:mfrac></x:template>   <x:template match="m:apply[*[1][self::m:partialdiff] and m:list and m:ci and count(*)=3]" priority="2"><m:mrow><m:msub><m:mi>D</m:mi><m:mrow><x:for-each select="m:list[1]/*"><x:apply-templates select="."/><x:if test="position()&lt;last()"><m:mo>,</m:mo></x:if></x:for-each></m:mrow></m:msub><m:mrow><x:apply-templates select="*[3]"/></m:mrow></m:mrow></x:template> <x:template match="m:apply[*[1][self::m:partialdiff]]" priority="1"><m:mfrac><m:mrow><x:choose>	<x:when test="not(m:bvar/m:degree) and not(m:bvar[2])">	<m:mo>&#8706;</m:mo>	</x:when>	<x:otherwise>	<m:msup><m:mo>&#8706;</m:mo>	<m:mrow>	<x:choose>	<x:when test="m:degree">		<x:apply-templates select="m:degree/node()"/>	</x:when>	<x:when test="m:bvar/m:degree[string(number(.))=\'NaN\']">		<x:for-each select="m:bvar/m:degree">		<x:apply-templates select="node()"/>		<x:if test="position()&lt;last()"><m:mo>+</m:mo></x:if>		</x:for-each>		<x:if test="count(m:bvar[not(m:degree)])&gt;0">		<m:mo>+</m:mo><m:mn><x:value-of select="count(m:bvar[not(m:degree)])"/></m:mn>		</x:if>	</x:when>	<x:otherwise>		<m:mn><x:value-of select="number(sum(m:bvar/m:degree))+count(m:bvar[not(m:degree)])"/></m:mn>	</x:otherwise>	</x:choose>	</m:mrow>	</m:msup>	</x:otherwise></x:choose><x:apply-templates  select="*[last()]"/></m:mrow><m:mrow><x:for-each select="m:bvar">	<m:mrow>	<m:mo>&#8706;</m:mo><m:msup><x:apply-templates select="node()"/>	<m:mrow><x:apply-templates select="m:degree/node()"/></m:mrow>	</m:msup>	</m:mrow></x:for-each></m:mrow></m:mfrac></x:template>  <x:template match="m:lowlimit"/>  <x:template match="m:uplimit"/>  <x:template match="m:bvar"><m:mi><x:apply-templates/></m:mi><x:if test="following-sibling::m:bvar"><m:mo>,</m:mo></x:if></x:template>  <x:template match="m:degree"/>  <x:template match="m:divergence"><m:mi>div</m:mi></x:template> <x:template match="m:apply[*[1][self::m:divergence]and m:bvar and m:vector]"><x:variable name="v" select="m:bvar"/><m:mrow><m:mi>div</m:mi><m:mo>&#8289;</m:mo><m:mo>(</m:mo><m:mtable><x:for-each select="m:vector/*"><x:variable name="p" select="position()"/><m:mtr><m:mtd><x:apply-templates select="$v[$p]/*"/><m:mo>&#x21a6;</m:mo><x:apply-templates select="."/></m:mtd></m:mtr></x:for-each></m:mtable><m:mo>)</m:mo></m:mrow></x:template>  <x:template match="m:grad"><m:mi>grad</m:mi></x:template> <x:template match="m:apply[*[1][self::m:grad]and m:bvar]"><m:mrow><m:mi>grad</m:mi><m:mo>&#8289;</m:mo><m:mrow><m:mo>(</m:mo><m:mfenced><x:apply-templates select="m:bvar/*"/></m:mfenced><m:mo>&#x21a6;</m:mo><x:apply-templates select="*[position()!=1][not(self::m:bvar)]"/><m:mo>)</m:mo></m:mrow></m:mrow></x:template>  <x:template match="m:curl"><m:mi>curl</m:mi></x:template>   <x:template match="m:laplacian"><m:msup><m:mo>&#8711;</m:mo><m:mn>2</m:mn></m:msup></x:template> <x:template match="m:apply[*[1][self::m:laplacian]and m:bvar]"><m:mrow><x:apply-templates select="*[1]"/><m:mo>&#8289;</m:mo><m:mrow><m:mo>(</m:mo><m:mfenced><x:apply-templates select="m:bvar/*"/></m:mfenced><m:mo>&#x21a6;</m:mo><x:apply-templates select="*[position()!=1][not(self::m:bvar)]"/><m:mo>)</m:mo></m:mrow></m:mrow></x:template>   <x:template match="m:set"><x:call-template name="set"/></x:template> <x:template  match="m:apply[*[1][self::m:csymbol=\'set\']]"><m:mfenced open="{{" close="}}" separators=","><x:apply-templates select="*[position()!=1]"/></m:mfenced></x:template>   <x:template match="m:list"><x:call-template name="set"><x:with-param name="o" select="\'(\'"/><x:with-param name="c" select="\')\'"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:csymbol=\'list\']]"><m:mfenced open="(" close=")" separators=","><x:apply-templates select="*[position()!=1]"/></m:mfenced></x:template>  <x:template match="m:apply[*[1][self::m:union]]                        |m:apply[*[1][self::m:csymbol=\'union\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8746;</m:mo></x:with-param></x:call-template></x:template> <x:template match="m:apply[*[1][self::m:union]][m:bvar] 				|m:apply[*[1][self::m:csymbol=\'union\']][m:bvar]" 	      priority="2" ><x:call-template name="sum"><x:with-param name="mo"><m:mo>&#x22C3;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:intersect]]                        |m:apply[*[1][self::m:csymbol=\'intersect\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="3"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8745;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:intersect]][m:bvar] 				|m:apply[*[1][self::m:csymbol=\'intersect\']][m:bvar]" 	      priority="2" ><x:call-template name="sum"><x:with-param name="mo"><m:mo>&#x22C2;</m:mo></x:with-param></x:call-template></x:template>    <x:template match="m:apply[*[1][self::m:in]]                        |m:apply[*[1][self::m:csymbol=\'in\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><m:mo>&#8712;</m:mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:notin]]                        |m:apply[*[1][self::m:csymbol=\'notin\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><m:mo>&#8713;</m:mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:subset]]                        |m:apply[*[1][self::m:csymbol=\'subset\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8838;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:prsubset]]                        |m:apply[*[1][self::m:csymbol=\'prsubset\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8834;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:notsubset]]                        |m:apply[*[1][self::m:csymbol=\'notsubset\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8840;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:notprsubset]]                        |m:apply[*[1][self::m:csymbol=\'notprsubset\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8836;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:setdiff]]                        |m:apply[*[1][self::m:csymbol=\'setdiff\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#8726;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:card]]                        |m:apply[*[1][self::m:csymbol=\'card\']]"><m:mrow><m:mo>|</m:mo><x:apply-templates select="*[2]"/><m:mo>|</m:mo></m:mrow></x:template>  <x:template match="m:apply[*[1][self::m:cartesianproduct or self::m:vectorproduct]] 				|m:apply[*[1][self::m:csymbol[.=\'cartesian_product\' or . = \'vectorproduct\']]]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#215;</m:mo></x:with-param></x:call-template></x:template> <x:template match="m:apply[*[1][self::m:cartesianproduct][count(following-sibling::m:reals)=count(following-sibling::*)]]" priority="2"><m:msup><x:apply-templates select="*[2]"><x:with-param name="p" select="5"/></x:apply-templates><m:mn><x:value-of select="count(*)-1"/></m:mn></m:msup></x:template>   <x:template name="sum" match="m:apply[*[1][self::m:sum]]                        |m:apply[*[1][self::m:csymbol=\'sum\']]"><x:param name="mo"><m:mo>&#8721;</m:mo></x:param><m:mrow><m:munderover><x:copy-of select="$mo"/><m:mrow><x:apply-templates select="m:lowlimit|m:interval/*[1]|m:condition/*|m:domainofapplication/*"/></m:mrow><m:mrow><x:apply-templates select="m:uplimit/*|m:interval/*[2]"/></m:mrow></m:munderover><x:apply-templates select="*[last()]"/></m:mrow></x:template> <x:template match="m:apply/m:lowlimit" priority="3"><m:mrow><x:if test="../m:bvar"><x:apply-templates select="../m:bvar/node()"/><m:mo>=</m:mo></x:if><x:apply-templates/></m:mrow></x:template>  <x:template match="m:apply[*[1][self::m:product]]                        |m:apply[*[1][self::m:csymbol=\'product\']]"><x:call-template name="sum"><x:with-param name="mo"><m:mo>&#8719;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:limit]]                        |m:apply[*[1][self::m:csymbol=\'limit\']]"><m:mrow><m:munder><m:mi>lim</m:mi><m:mrow><x:apply-templates select="m:lowlimit|m:condition/*"/></m:mrow></m:munder><x:apply-templates select="*[last()]"/></m:mrow></x:template> <x:template match="m:apply[m:limit]/m:lowlimit" priority="4"><m:mrow><x:apply-templates select="../m:bvar/node()"/><m:mo>&#8594;</m:mo><x:apply-templates/></m:mrow></x:template>   <x:template match="m:apply[*[1][self::m:tendsto]]|m:reln[*[1][self::m:tendsto]]"><x:param name="p"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo><x:choose><x:when test="@type=\'above\'">&#8600;</x:when><x:when test="@type=\'below\'">&#8599;</x:when><x:when test="@type=\'two-sided\'">&#8594;</x:when><x:otherwise>&#8594;</x:otherwise></x:choose></m:mo></x:with-param></x:call-template></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'tendsto\']]"><m:mrow><x:apply-templates select="*[3]"/><m:mo><x:choose>	<x:when test="*[1][self::above]">&#8600;</x:when>	<x:when test="*[1][self::below]">&#8599;</x:when>	<x:when test="*[1][self::two-sided]">&#8594;</x:when>	<x:otherwise>&#8594;</x:otherwise></x:choose></m:mo><x:apply-templates select="*[4]"/></m:mrow></x:template>  <x:template match="m:apply[*[1][  self::m:sin or self::m:cos or self::m:tan or self::m:sec or  self::m:csc or self::m:cot or self::m:sinh or self::m:cosh or  self::m:tanh or self::m:sech or self::m:csch or self::m:coth or  self::m:arcsin or self::m:arccos or self::m:arctan or self::m:arccosh  or self::m:arccot or self::m:arccoth or self::m:arccsc or  self::m:arccsch or self::m:arcsec or self::m:arcsech or  self::m:arcsinh or self::m:arctanh or self::m:ln]]"><m:mrow><m:mi><x:value-of select="local-name(*[1])"/></m:mi><m:mo>&#8289;</m:mo><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates></m:mrow></x:template>  <x:template match="  m:sin | m:cos | m:tan | m:sec |  m:csc | m:cot | m:sinh | m:cosh |  m:tanh | m:sech | m:csch | m:coth |  m:arcsin | m:arccos | m:arctan | m:arccosh  | m:arccot | m:arccoth | m:arccsc |  m:arccsch | m:arcsec | m:arcsech |  m:arcsinh | m:arctanh | m:ln|m:mean"><m:mi><x:value-of select="local-name()"/></m:mi></x:template>     <x:template match="m:apply[*[1][self::m:exp]]                        |m:apply[*[1][self::m:csymbol=\'exp\']]"><m:msup><m:mi>e</m:mi><m:mrow><x:apply-templates select="*[2]"/></m:mrow></m:msup></x:template>     <x:template match="m:apply[*[1][self::m:log]]                        |m:apply[*[1][self::m:csymbol=\'log\']]"><m:mrow><x:choose><x:when test="not(m:logbase) or m:logbase=10"><m:mi>log</m:mi></x:when><x:otherwise><m:msub><m:mi>log</m:mi><m:mrow><x:apply-templates select="m:logbase/node()"/></m:mrow></m:msub></x:otherwise></x:choose><m:mo>&#8289;</m:mo><x:apply-templates select="*[last()]"><x:with-param name="p" select="7"/></x:apply-templates></m:mrow></x:template>   <x:template match="m:apply[*[1][self::m:mean]]                        |m:apply[*[1][self::m:csymbol=\'mean\']]"><m:mrow><m:mo>&#9001;</m:mo><x:for-each select="*[position()&gt;1]"><x:apply-templates select="."/><x:if test="position() !=last()"><m:mo>,</m:mo></x:if></x:for-each><m:mo>&#9002;</m:mo></m:mrow></x:template>   <x:template match="m:sdev"><m:mo>&#963;</m:mo></x:template>  <x:template match="m:apply[*[1][self::m:variance]]                        |m:apply[*[1][self::m:csymbol=\'variance\']]"><m:msup><m:mrow><m:mo>&#963;</m:mo><m:mo>&#8289;</m:mo><m:mfenced><x:apply-templates select="*[position()!=1]"/></m:mfenced></m:mrow><m:mn>2</m:mn></m:msup></x:template>   <x:template match="m:median"><m:mi>median</m:mi></x:template>   <x:template match="m:mode"><m:mi>mode</m:mi></x:template>  <x:template match="m:apply[*[1][self::m:moment]] 				|m:apply[*[1][self::m:csymbol=\'moment\']]"><m:mrow><m:mo>&#9001;</m:mo><m:msup><x:variable name="data" 		    select="*[not(position()=1)] 			    [not(self::m:degree or self::m:momentabout)]"/><x:choose>	<x:when test="$data[2]">	<m:mfenced>	<x:apply-templates select="$data"/>	</m:mfenced>	</x:when>	<x:otherwise>	<x:apply-templates select="$data"/>	</x:otherwise></x:choose><m:mrow><x:apply-templates select="m:degree/node()"/></m:mrow></m:msup><m:mo>&#9002;</m:mo></m:mrow></x:template>  <x:template match="m:momentabout"/> <x:template match="m:apply[*[1][self::m:moment]][m:momentabout]" priority="2"><m:msub><m:mrow><m:mo>&#9001;</m:mo><m:msup>	<x:variable name="data" 		      select="*[not(position()=1)] 			      [not(self::m:degree or self::m:momentabout)]"/>	<x:choose>	<x:when test="$data[2]">	<m:mfenced>	<x:apply-templates select="$data"/>	</m:mfenced>	</x:when>	<x:otherwise>	<x:apply-templates select="$data"/>	</x:otherwise>	</x:choose>	<m:mrow><x:apply-templates select="m:degree/node()"/></m:mrow></m:msup><m:mo>&#9002;</m:mo></m:mrow><m:mrow><x:apply-templates select="m:momentabout/*"/></m:mrow></m:msub></x:template>  <x:template match="m:vector"><m:mrow><m:mo>(</m:mo><m:mtable><x:for-each select="*"><m:mtr><m:mtd><x:apply-templates select="."/></m:mtd></m:mtr></x:for-each></m:mtable><m:mo>)</m:mo></m:mrow></x:template>  <x:template match="m:vector[m:condition]"><m:mrow><m:mo>[</m:mo><x:apply-templates select="*[last()]"/><m:mo>|</m:mo><x:apply-templates select="m:condition"/><m:mo>]</m:mo></m:mrow></x:template> <x:template match="m:vector[m:domainofapplication]"><m:mrow><m:mo>[</m:mo><x:apply-templates select="*[last()]"/><m:mo>|</m:mo><x:apply-templates select="m:bvar/*"/><m:mo>&#x2208;</m:mo><x:apply-templates select="m:domainofapplication/*"/><m:mo>]</m:mo></m:mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'vector\']]"><m:mrow><m:mo>(</m:mo><m:mtable><x:for-each select="*[position()!=1]"><m:mtr><m:mtd><x:apply-templates select="."/></m:mtd></m:mtr></x:for-each></m:mtable><m:mo>)</m:mo></m:mrow></x:template>  <x:template match="m:matrix"><m:mrow><m:mo>(</m:mo><m:mtable><x:apply-templates/></m:mtable><m:mo>)</m:mo></m:mrow></x:template> <x:template match="m:matrix[m:condition]"><m:mrow><m:mo>[</m:mo><m:msub><m:mi>m</m:mi><m:mrow>	<x:for-each select="m:bvar">	<x:apply-templates/>	<x:if test="position()!=last()"><m:mo>,</m:mo></x:if>	</x:for-each></m:mrow></m:msub><m:mo>|</m:mo><m:mrow><m:msub>	<m:mi>m</m:mi>	<m:mrow>	<x:for-each select="m:bvar">	<x:apply-templates/>	<x:if test="position()!=last()"><m:mo>,</m:mo></x:if>	</x:for-each>	</m:mrow></m:msub><m:mo>=</m:mo><x:apply-templates select="*[last()]"/></m:mrow><m:mo>;</m:mo><x:apply-templates select="m:condition"/><m:mo>]</m:mo></m:mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'matrix\']]"><m:mrow><m:mo>(</m:mo><m:mtable><x:apply-templates select="*[position()!=1]"/></m:mtable><m:mo>)</m:mo></m:mrow></x:template>   <x:template match="m:matrix/m:matrixrow"><m:mtr><x:for-each select="*"><m:mtd><x:apply-templates select="."/></m:mtd></x:for-each></m:mtr></x:template> <x:template match="m:matrixrow"><m:mtable><m:mtr><x:for-each select="*"><m:mtd><x:apply-templates select="."/></m:mtd></x:for-each></m:mtr></m:mtable></x:template> <x:template match="m:apply[*[1][self::m:csymbol.=\'matrixrow\']]"><m:mtr><x:for-each select="*[position()!=1]"><m:mtd><x:apply-templates select="."/></m:mtd></x:for-each></m:mtr></x:template>  <x:template match="m:apply[*[1][self::m:determinant]]                        |m:apply[*[1][self::m:csymbol=\'determinant\']]"><m:mrow><m:mi>det</m:mi><m:mo>&#8289;</m:mo><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates></m:mrow></x:template> <x:template match="m:apply[*[1][self::m:determinant]][*[2][self::m:matrix]]" priority="2"><m:mrow><m:mo>|</m:mo><m:mtable><x:apply-templates select="m:matrix/*"/></m:mtable><m:mo>|</m:mo></m:mrow></x:template>  <x:template match="m:apply[*[1][self::m:transpose]]                        |m:apply[*[1][self::m:csymbol=\'transpose\']]"><m:msup><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates><m:mi>T</m:mi></m:msup></x:template>  <x:template match="m:apply[*[1][self::m:selector]]                        |m:apply[*[1][self::m:csymbol=\'selector\']]"><m:msub><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates><m:mrow><x:for-each select="*[position()&gt;2]"><x:apply-templates select="."/><x:if test="position() !=last()"><m:mo>,</m:mo></x:if></x:for-each></m:mrow></m:msub></x:template>      <x:template match="m:apply[*[1][self::m:scalarproduct]]                        |m:apply[*[1][self::m:csymbol=\'scalarproduct\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>.</m:mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:outerproduct]]                        |m:apply[*[1][self::m:csymbol=\'outerproduct\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><m:mo>&#x2297;</m:mo></x:with-param></x:call-template></x:template>  <x:template match="m:semantics"><x:apply-templates select="*[1]"/></x:template><x:template match="m:semantics[m:annotation-xml/@encoding=\'MathML-Presentation\']"><x:apply-templates select="m:annotation-xml[@encoding=\'MathML-Presentation\']/node()"/></x:template>  <x:template match="m:integers"><m:mi mathvariant="double-struck">Z</m:mi></x:template>  <x:template match="m:reals"><m:mi mathvariant="double-struck">R</m:mi></x:template>  <x:template match="m:rationals"><m:mi mathvariant="double-struck">Q</m:mi></x:template>  <x:template match="m:naturalnumbers"><m:mi mathvariant="double-struck">N</m:mi></x:template>  <x:template match="m:complexes"><m:mi mathvariant="double-struck">C</m:mi></x:template>  <x:template match="m:primes"><m:mi mathvariant="double-struck">P</m:mi></x:template>  <x:template match="m:exponentiale"><m:mi>e</m:mi></x:template>  <x:template match="m:imaginaryi"><m:mi>i</m:mi></x:template>  <x:template match="m:notanumber"><m:mi>NaN</m:mi></x:template>  <x:template match="m:true"><m:mi>true</m:mi></x:template>  <x:template match="m:false"><m:mi>false</m:mi></x:template>  <x:template match="m:emptyset|m:csymbol[.=\'emptyset\']"><m:mi>&#8709;</m:mi></x:template>   <x:template match="m:pi|m:csymbol[.=\'pi\']"><m:mi>&#960;</m:mi></x:template>  <x:template match="m:eulergamma|m:csymbol[.=\'gamma\']"><m:mi>&#947;</m:mi></x:template>  <x:template match="m:infinity|m:csymbol[.=\'infinity\']"><m:mi>&#8734;</m:mi></x:template>   <x:template name="infix" ><x:param name="mo"/><x:param name="p" select="0"/><x:param name="this-p" select="0"/><m:mrow><x:if test="$this-p &lt; $p"><m:mo>(</m:mo></x:if><x:for-each select="*[position()&gt;1]"><x:if test="position() &gt; 1"><x:copy-of select="$mo"/></x:if><x:apply-templates select="."><x:with-param name="p" select="$this-p"/></x:apply-templates></x:for-each><x:if test="$this-p &lt; $p"><m:mo>)</m:mo></x:if></m:mrow></x:template> <x:template name="binary" ><x:param name="mo"/><x:param name="p" select="0"/><x:param name="this-p" select="0"/><m:mrow><x:if test="$this-p &lt; $p"><m:mo>(</m:mo></x:if><x:apply-templates select="*[2]"><x:with-param name="p" select="$this-p"/></x:apply-templates><x:copy-of select="$mo"/><x:apply-templates select="*[3]"><x:with-param name="p" select="$this-p"/></x:apply-templates><x:if test="$this-p &lt; $p"><m:mo>)</m:mo></x:if></m:mrow></x:template> <x:template name="set" ><x:param name="o" select="\'{\'"/><x:param name="c" select="\'}\'"/><m:mrow><m:mo><x:value-of select="$o"/></m:mo><x:choose><x:when test="m:condition"><m:mrow><x:apply-templates select="m:bvar/*[not(self::m:bvar or self::m:condition)]"/></m:mrow><m:mo>|</m:mo><m:mrow><x:apply-templates select="m:condition/node()"/></m:mrow></x:when><x:otherwise><x:for-each select="*[not(position()=1 and parent::m:apply)]"><x:apply-templates select="."/><x:if test="position() !=last()"><m:mo>,</m:mo></x:if></x:for-each></x:otherwise></x:choose><m:mo><x:value-of select="$c"/></m:mo></m:mrow></x:template>    <x:template match="m:cs"><m:ms><x:value-of select=" 			 translate(., 			 \'&#9;&#10;&#13;&#32;\', 			 \'&#160;&#160;&#160;&#160;\')"/></m:ms></x:template> <x:template match="m:cbytes"><m:mrow/></x:template> <x:template match="m:cerror"><m:merror><x:apply-templates/></m:merror></x:template>    <x:template match="*[@dir=\'rtl\']" ><x:copy><x:apply-templates select="@*|node()" mode="rtl"/></x:copy></x:template> <x:template match="@*" mode="rtl"><x:copy-of select="."/></x:template><x:template match="*" mode="rtl"><x:copy><x:apply-templates select="@*" mode="rtl"/><x:apply-templates mode="rtl"><x:sort data-type="number" order="descending" select="position()"/></x:apply-templates></x:copy></x:template><x:template match="mfenced" mode="rtl"><x:copy><x:apply-templates select="@*" mode="rtl"/><x:attribute name="open"><x:apply-templates select="@close" mode="rtl"/></x:attribute><x:attribute name="close"><x:apply-templates select="@open" mode="rtl"/></x:attribute><x:apply-templates mode="rtl"><x:sort data-type="number" order="descending" select="position()"/></x:apply-templates></x:copy></x:template><x:template match="m:mtable|m:munder|m:over|m:munderover" mode="rtl" priority="2"><x:copy><x:apply-templates select="@*" mode="rtl"/><x:apply-templates mode="rtl"></x:apply-templates></x:copy></x:template><x:template match="m:msup" mode="rtl" priority="2"><m:mmultiscripts><x:apply-templates select="*[1]" mode="rtl"/><m:mprescripts/><m:none/><x:apply-templates select="*[2]" mode="rtl"/></m:mmultiscripts></x:template><x:template match="m:msub" mode="rtl" priority="2"><m:mmultiscripts><x:apply-templates select="*[1]" mode="rtl"/><m:mprescripts/><x:apply-templates select="*[2]" mode="rtl"/><m:none/></m:mmultiscripts></x:template><x:template match="m:msubsup" mode="rtl" priority="2"><m:mmultiscripts><x:apply-templates select="*[1]" mode="rtl"/><m:mprescripts/><x:apply-templates select="*[2]" mode="rtl"/><x:apply-templates select="*[3]" mode="rtl"/></m:mmultiscripts></x:template><x:template match="m:mmultiscripts" mode="rtl" priority="2"><m:mmultiscripts><x:apply-templates select="*[1]" mode="rtl"/><x:apply-templates select="m:mprescripts/following-sibling::*" mode="rtl"><x:sort data-type="number" order="descending" select="position()"/></x:apply-templates><m:mprescripts/><x:apply-templates select="m:mprescripts/preceding-sibling::*[position()!=last()]" mode="rtl"><x:sort data-type="number" order="descending" select="position()"/></x:apply-templates></m:mmultiscripts></x:template><x:template match="text()[.=\'(\']" mode="rtl">)</x:template><x:template match="text()[.=\')\']" mode="rtl">(</x:template><x:template match="text()[.=\'{\']" mode="rtl">}</x:template><x:template match="text()[.=\'}\']" mode="rtl">{</x:template><x:template match="text()[.=\'&lt;\']" mode="rtl">&gt;</x:template><x:template match="text()[.=\'&gt;\']" mode="rtl">&lt;</x:template><x:template match="text()[.=\'&#x2208;\']" mode="rtl">&#x220b;</x:template><x:template match="text()[.=\'&#x220b;\']" mode="rtl">&#x2208;</x:template><x:template match="text()[.=\'&#x2211;\']|text()[.=\'&#x222b;\']" mode="rtl"><svg width="20" height="20" version="1.1" xmlns="http://www.w3.org/2000/svg"><g transform="matrix(-1 0 0 1 0 0 )"><text id="TextElement" x="-20" y="15" >	<x:value-of select="."/></text></g></svg></x:template>  <x:template name="mml2attrib"><x:copy-of select="@*[not(local-name()=\'href\')]"/><x:attribute name="style"><x:if test="@style"><x:value-of select="@style"/>;</x:if><x:if test="@mathcolor">color:<x:value-of select="@mathcolor"/>;</x:if><x:if test="@mathbackground">background-color:<x:value-of select="@mathbackground"/>;</x:if></x:attribute></x:template>   <x:template match="*[@href]" priority="3"><a xmlns="http://www.w3.org/1999/xhtml" style="text-decoration: none" href="{@href}"><x:copy><x:call-template name="mml2attrib"/><x:attribute name="class">	<x:text>mmlhref</x:text>	<x:value-of select="@class"/></x:attribute><x:apply-templates/></x:copy></a></x:template> <x:template match="*[@mathcolor|@mathbackground]"><x:copy><x:call-template name="mml2attrib"/><x:apply-templates/></x:copy></x:template>   </x:stylesheet>', "text/xml");

window.addEventListener("load", function(e) {

var mm = document.getElementsByTagNameNS('http://www.w3.org/1998/Math/MathML','math');
if(mm.length > 0) {
//alert("Content mathml is here");


 var proc = new XSLTProcessor();
    proc.importStylesheet(xslt);

for (var i = 0; i< mm.length;i++){

var newmath=proc.transformToFragment(mm[i],document);
//alert(i);
mm[i].parentNode.replaceChild(newmath,mm[i]); 
}
// var dataString = (new XMLSerializer()).serializeToString(newdocument);
//alert(dataString);
//alert("Content mathml is now presentation");


// hmph this seems to hit a greasemonkey security block
// so back to putting in xhtml a links in the xslt.
//var lists = document.getElementsByClassName("mmlhref");
//for (var i = 0; i < lists.length; i++) {
//    lists[i].onclick = function(){window.location=this.getAttribute('href')};
//}


}
else {
// alert("Content mathml is NOT  here")
}

}, false);