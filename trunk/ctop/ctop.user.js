// ==UserScript==
// @name          ctop
// @namespace     http://w3c.org/Math
// @description   ctop
// @include       http://www.w3.org/Math/testsuite/*
// @include       http://www.w3.org/TR/MathML/*
// ==/UserScript==






var xslt = new DOMParser().parseFromString('<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:m="http://www.w3.org/1998/Math/MathML" > <!-- $Id: ctop.xsl,v 1.3 2002/09/20 08:41:39 davidc Exp $ Copyright David Carlisle 2001, 2002, 2008. Use and distribution of this code are permitted under the terms of the <a href="http://www.w3.org/Consortium/Legal/copyright-software-19980720" >W3C Software Notice and License</a>. 2001-2002 MathML2 version 2008 Updates for MathML3 --> <xsl:output method="xml" /> <xsl:template match="/"> <xsl:apply-templates /> </xsl:template> <xsl:template  match="*"> <xsl:copy> <xsl:copy-of select="@*"/> <xsl:apply-templates /> </xsl:copy> </xsl:template> <xsl:template  match="m:cn"> <m:mn><xsl:apply-templates /></m:mn> </xsl:template> <xsl:template  match="m:cn[@type=\'complex-cartesian\']"> <m:mrow> <m:mn><xsl:apply-templates  select="text()[1]"/></m:mn> <m:mo>+</m:mo> <m:mn><xsl:apply-templates  select="text()[2]"/></m:mn> <m:mo></m:mo> <m:mi>i</m:mi> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:csymbol=\'complex_cartesian\']]"> <m:mrow> <m:mn><xsl:apply-templates  select="*[2]"/></m:mn> <m:mo>+</m:mo> <m:mn><xsl:apply-templates  select="*[3]"/></m:mn> <m:mo></m:mo> <m:mi>i</m:mi> </m:mrow> </xsl:template> <xsl:template  match="m:cn[@type=\'rational\']"> <m:mrow> <m:mn><xsl:apply-templates  select="text()[1]"/></m:mn> <m:mo>/</m:mo> <m:mn><xsl:apply-templates  select="text()[2]"/></m:mn> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:csymbol=\'rational\']]"> <m:mrow> <m:mn><xsl:apply-templates  select="*[2]"/></m:mn> <m:mo>/</m:mo> <m:mn><xsl:apply-templates  select="*[3]"/></m:mn> </m:mrow> </xsl:template> <xsl:template  match="m:cn[@type=\'integer\']"> <xsl:choose> <xsl:when test="not(@base) or @base=10"> <m:mn><xsl:apply-templates /></m:mn> </xsl:when> <xsl:otherwise> <m:msub> <m:mn><xsl:apply-templates /></m:mn> <m:mn><xsl:value-of select="@base"/></m:mn> </m:msub> </xsl:otherwise> </xsl:choose> </xsl:template> <xsl:template  match="m:cn[@type=\'complex-polar\']"> <m:mrow> <m:mn><xsl:apply-templates  select="text()[1]"/></m:mn> <m:mo></m:mo> <m:msup> <m:mi>e</m:mi> <m:mrow> <m:mi>i</m:mi> <m:mo></m:mo> <m:mn><xsl:apply-templates  select="text()[2]"/></m:mn> </m:mrow> </m:msup> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:csymbol=\'complex_polar\']]"> <m:mrow> <xsl:apply-templates  select="*[2]"/> <m:mo></m:mo> <m:msup> <m:mi>e</m:mi> <m:mrow> <m:mi>i</m:mi> <m:mo></m:mo> <xsl:apply-templates  select="*[3]"/> </m:mrow> </m:msup> </m:mrow> </xsl:template> <xsl:template  match="m:cn[@type=\'e-notation\']"> <m:mn><xsl:apply-templates  select="text()[1]"/>E<xsl:apply-templates  select="text()[2]"/></m:mn> </xsl:template> <xsl:template  match="m:ci/text()"> <m:mi><xsl:value-of select="."/></m:mi> </xsl:template> <xsl:template  match="m:ci"> <m:mrow><xsl:apply-templates /></m:mrow> </xsl:template> <xsl:template  match="m:csymbol/text()"> <m:mi><xsl:value-of select="."/></m:mi> </xsl:template> <xsl:template  match="m:csymbol"> <m:mrow><xsl:apply-templates /></m:mrow> </xsl:template> <xsl:template  match="m:apply|m:reln"> <m:mrow> <xsl:choose> <xsl:when test="*[1]/*/*"> <m:mfenced separators=""> <xsl:apply-templates  select="*[1]"> <xsl:with-param name="p" select="10"/> </xsl:apply-templates> </m:mfenced> </xsl:when> <xsl:otherwise> <xsl:apply-templates  select="*[1]"> <xsl:with-param name="p" select="10"/> </xsl:apply-templates> </xsl:otherwise> </xsl:choose> <m:mo></m:mo> <m:mfenced open="(" close=")" separators=","> <xsl:apply-templates  select="*[position()>1]"/> </m:mfenced> </m:mrow> </xsl:template> <xsl:template  match="m:bind"> <m:mrow> <xsl:choose> <xsl:when test="*[1]/*/*"> <m:mfenced separators=""> <xsl:apply-templates  select="*[1]"> <xsl:with-param name="p" select="10"/> </xsl:apply-templates> </m:mfenced> </xsl:when> <xsl:otherwise> <xsl:apply-templates  select="*[1]"> <xsl:with-param name="p" select="10"/> </xsl:apply-templates> </xsl:otherwise> </xsl:choose> <xsl:apply-templates select="bvar/*"/> <m:mo>.</m:mo> <xsl:apply-templates  select="*[position()>1][not(self::m:bvar)]"/> </m:mrow> </xsl:template> <xsl:template  match="m:fn"> <m:mrow><xsl:apply-templates /></m:mrow> </xsl:template> <xsl:template  match="m:interval[*[2]]"> <m:mfenced open="[" close="]"><xsl:apply-templates /></m:mfenced> </xsl:template> <xsl:template  match="m:interval[*[2]][@closure=\'open\']" priority="2"> <m:mfenced open="(" close=")"><xsl:apply-templates /></m:mfenced> </xsl:template> <xsl:template  match="m:interval[*[2]][@closure=\'open-closed\']" priority="2"> <m:mfenced open="(" close="]"><xsl:apply-templates /></m:mfenced> </xsl:template> <xsl:template  match="m:interval[*[2]][@closure=\'closed-open\']" priority="2"> <m:mfenced open="[" close=")"><xsl:apply-templates /></m:mfenced> </xsl:template> <xsl:template  match="m:interval"> <m:mfenced open="{{" close="}}"><xsl:apply-templates /></m:mfenced> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:inverse]] |m:apply[*[1][self::m:csymbol=\'inverse\']]"> <m:msup> <xsl:apply-templates  select="*[2]"/> <m:mrow><m:mo>(</m:mo><m:mn>-1</m:mn><m:mo>)</m:mo></m:mrow> </m:msup> </xsl:template> <xsl:template  match="m:condition"> <m:mrow><xsl:apply-templates /></m:mrow> </xsl:template> <xsl:template  match="m:declare"/> <xsl:template  match="m:apply[*[1][self::m:lambda]] |m:apply[*[1][self::m:csymbol=\'lambda\']] |m:bind[*[1][self::m:csymbol=\'lambda\']]"> <m:mrow> <m:mi>&#955;</m:mi> <m:mrow><xsl:apply-templates  select="m:bvar/*"/></m:mrow> <m:mo>.</m:mo> <m:mfenced> <xsl:apply-templates  select="*[last()]"/> </m:mfenced> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:compose]] |m:apply[*[1][self::m:csymbol=\'left_compose\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="1"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8728;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:ident"> <m:mo>id</m:mo> </xsl:template> <xsl:template  match="m:domain"> <m:mo>domain</m:mo> </xsl:template> <xsl:template  match="m:codomain"> <m:mo>codomain</m:mo> </xsl:template> <xsl:template  match="m:image"> <m:mo>image</m:mo> </xsl:template> <xsl:template  match="m:domainofapplication"> <m:error/> </xsl:template> <xsl:template  match="m:piecewise"> <m:mrow> <m:mo>{</m:mo> <m:mtable> <xsl:for-each select="m:piece|m:otherwise"> <m:mtr> <m:mtd><xsl:apply-templates  select="*[1]"/></m:mtd> <xsl:choose> <xsl:when test="self::m:piece"> <m:mtd columnalign="left"><m:mtext>&#160; if &#160;</m:mtext></m:mtd> <m:mtd><xsl:apply-templates  select="*[2]"/></m:mtd> </xsl:when> <xsl:otherwise> <m:mtd colspan="2" columnalign="left"><m:mtext>&#160; otherwise</m:mtext></m:mtd> </xsl:otherwise> </xsl:choose> </m:mtr> </xsl:for-each> </m:mtable> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:quotient]] |m:apply[*[1][self::m:csymbol=\'quotient\']]"> <m:mrow> <m:mo>&#8970;</m:mo> <xsl:apply-templates  select="*[2]"/> <m:mo>/</m:mo> <xsl:apply-templates  select="*[3]"/> <m:mo>&#8971;</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:factorial]] |m:apply[*[1][self::m:csymbol=\'factorial\']]"> <m:mrow> <xsl:apply-templates  select="*[2]"> <xsl:with-param name="p" select="7"/> </xsl:apply-templates> <m:mo>!</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:divide]] |m:apply[*[1][self::m:csymbol=\'divide\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="binary"> <xsl:with-param name="mo"><m:mo>/</m:mo></xsl:with-param> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="this-p" select="3"/> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:max]] |m:apply[*[1][self::m:csymbol=\'max\']]"> <m:mrow> <m:mo>max</m:mo> <xsl:call-template name="set"/> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:min]]|m:reln[*[1][self::m:min]]"> <m:mrow> <m:mo>min</m:mo> <xsl:call-template name="set"/> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:minus] and count(*)=2] |m:apply[*[1][self::m:csymbol=\'unary_minus\']]"> <m:mrow> <m:mo>&#8722;</m:mo> <xsl:apply-templates  select="*[2]"> <xsl:with-param name="p" select="5"/> </xsl:apply-templates> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:minus] and count(*)&gt;2] |m:apply[*[1][self::m:csymbol=\'minus\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="binary"> <xsl:with-param name="mo"><m:mo>&#8722;</m:mo></xsl:with-param> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="this-p" select="2"/> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:plus]] |m:apply[*[1][self::m:csymbol=\'plus\']]"> <xsl:param name="p" select="0"/> <m:mrow> <xsl:if test="$p &gt; 2"><m:mo>(</m:mo></xsl:if> <xsl:for-each select="*[position()&gt;1]"> <xsl:if test="position() &gt; 1"> <m:mo> <xsl:choose> <xsl:when test="self::m:apply[*[1][self::m:times] and *[2][self::m:apply/*[1][self::m:minus] or self::m:cn[not(m:sep) and (number(.) &lt; 0)]]]">&#8722;</xsl:when> <xsl:otherwise>+</xsl:otherwise> </xsl:choose> </m:mo> </xsl:if> <xsl:choose> <xsl:when test="self::m:apply[*[1][self::m:times] and *[2][self::m:cn[not(m:sep) and (number(.) &lt;0)]]]"> <m:mrow> <m:mn><xsl:value-of select="-(*[2])"/></m:mn> <m:mo></m:mo> <xsl:apply-templates  select="."> <xsl:with-param name="first" select="2"/> <xsl:with-param name="p" select="2"/> </xsl:apply-templates> </m:mrow> </xsl:when> <xsl:when test="self::m:apply[*[1][self::m:times] and *[2][self::m:apply/*[1][self::m:minus]]]"> <m:mrow> <xsl:apply-templates  select="./*[2]/*[2]"/> <xsl:apply-templates  select="."> <xsl:with-param name="first" select="2"/> <xsl:with-param name="p" select="2"/> </xsl:apply-templates> </m:mrow> </xsl:when> <xsl:otherwise> <xsl:apply-templates  select="."> <xsl:with-param name="p" select="2"/> </xsl:apply-templates> </xsl:otherwise> </xsl:choose> </xsl:for-each> <xsl:if test="$p &gt; 2"><m:mo>)</m:mo></xsl:if> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:power]] |m:apply[*[1][self::m:csymbol=\'power\']]"> <m:msup> <xsl:apply-templates  select="*[2]"> <xsl:with-param name="p" select="5"/> </xsl:apply-templates> <xsl:apply-templates  select="*[3]"> <xsl:with-param name="p" select="5"/> </xsl:apply-templates> </m:msup> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:rem]] |m:apply[*[1][self::m:csymbol=\'rem\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="binary"> <xsl:with-param name="mo"><m:mo>mod</m:mo></xsl:with-param> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="this-p" select="3"/> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:times]] |m:apply[*[1][self::m:csymbol=\'times\']]" name="times"> <xsl:param name="p" select="0"/> <xsl:param name="first" select="1"/> <m:mrow> <xsl:if test="$p &gt; 3"><m:mo>(</m:mo></xsl:if> <xsl:for-each select="*[position()&gt;1]"> <xsl:if test="position() &gt; 1"> <m:mo> <xsl:choose> <xsl:when test="self::m:cn">&#215;</xsl:when> <xsl:otherwise></xsl:otherwise> </xsl:choose> </m:mo> </xsl:if> <xsl:if test="position()&gt;= $first"> <xsl:apply-templates  select="."> <xsl:with-param name="p" select="3"/> </xsl:apply-templates> </xsl:if> </xsl:for-each> <xsl:if test="$p &gt; 3"><m:mo>)</m:mo></xsl:if> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:root] and not(m:degree) or m:degree=2]" priority="4"> <m:msqrt> <xsl:apply-templates  select="*[position()&gt;1]"/> </m:msqrt> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:root]]"> <m:mroot> <xsl:apply-templates  select="*[position()&gt;1 and not(self::m:degree)]"/> <m:mrow><xsl:apply-templates  select="m:degree/*"/></m:mrow> </m:mroot> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:csymbol=\'root\']]"> <m:mroot> <xsl:apply-templates  select="*[position()!=1]"/> </m:mroot> </xsl:template> <xsl:template  match="m:gcd"> <m:mo>gcd</m:mo> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:and]] |m:reln[*[1][self::m:and]] |m:apply[*[1][self::m:csymbol=\'and\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="2"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8743;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:or]] |m:apply[*[1][self::m:csymbol=\'or\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="3"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8744;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:xor]] |m:apply[*[1][self::m:csymbol=\'xor\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="3"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>xor</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:not]] |m:apply[*[1][self::m:csymbol=\'not\']]"> <m:mrow> <m:mo>&#172;</m:mo> <xsl:apply-templates  select="*[2]"> <xsl:with-param name="p" select="7"/> </xsl:apply-templates> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:implies]] |m:reln[*[1][self::m:implies]] |m:apply[*[1][self::m:csymbol=\'implies\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="binary"> <xsl:with-param name="mo"><m:mo>&#8658;</m:mo></xsl:with-param> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="this-p" select="3"/> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:forall]] |m:apply[*[1][self::m:csymbol=\'forall\']] |m:bind[*[1][self::m:csymbol=\'forall\']]"> <m:mrow> <m:mi>&#8704;</m:mi> <m:mrow><xsl:apply-templates  select="m:bvar[not(current()/m:condition)]/*|m:condition/*"/></m:mrow> <m:mo>.</m:mo> <m:mfenced> <xsl:apply-templates  select="*[last()]"/> </m:mfenced> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:exists]] |m:apply[*[1][self::m:csymbol=\'exists\']] |m:bind[*[1][self::m:csymbol=\'exists\']]"> <m:mrow> <m:mi>&#8707;</m:mi> <m:mrow><xsl:apply-templates  select="m:bvar[not(current()/m:condition)]/*|m:condition/*"/></m:mrow> <m:mo>.</m:mo> <m:mfenced> <xsl:apply-templates  select="*[last()]"/> </m:mfenced> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:abs]] |m:apply[*[1][self::m:csymbol=\'abs\']]"> <m:mrow> <m:mo>|</m:mo> <xsl:apply-templates  select="*[2]"/> <m:mo>|</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:conjugate]] |m:apply[*[1][self::m:csymbol=\'conjugate\']]"> <m:mover> <xsl:apply-templates  select="*[2]"/> <m:mo>&#175;</m:mo> </m:mover> </xsl:template> <xsl:template  match="m:arg"> <m:mo>arg</m:mo> </xsl:template> <xsl:template  match="m:real|m:csymbol[.=\'real\']"> <m:mo>&#8475;</m:mo> </xsl:template> <xsl:template  match="m:imaginary|m:csymbol[.=\'imaginary\']"> <m:mo>&#8465;</m:mo> </xsl:template> <xsl:template  match="m:lcm"> <m:mo>lcm</m:mo> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:floor]] |m:apply[*[1][self::m:csymbol=\'floor\']]"> <m:mrow> <m:mo>&#8970;</m:mo> <xsl:apply-templates  select="*[2]"/> <m:mo>&#8971;</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:ceiling]] |m:apply[*[1][self::m:csymbol=\'ceiling\']]"> <m:mrow> <m:mo>&#8968;</m:mo> <xsl:apply-templates  select="*[2]"/> <m:mo>&#8969;</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:eq]] |m:reln[*[1][self::m:eq]] |m:apply[*[1][self::m:csymbol=\'eq\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="1"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>=</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:neq]] |m:apply[*[1][self::m:csymbol=\'neq\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="1"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8800;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:gt]] |m:reln[*[1][self::m:gt]] |m:apply[*[1][self::m:csymbol=\'gt\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="1"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&gt;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:lt]] |m:reln[*[1][self::m:lt]] |m:apply[*[1][self::m:csymbol=\'lt\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="1"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&lt;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:geq]] |m:apply[*[1][self::m:csymbol=\'geq\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="1"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8805;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:leq]] |m:apply[*[1][self::m:csymbol=\'leq\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="1"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8804;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:equivalent]] |m:apply[*[1][self::m:csymbol=\'equivalent\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="1"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8801;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:approx]] |m:apply[*[1][self::m:csymbol=\'approx\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="1"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8771;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:factorof]] |m:apply[*[1][self::m:csymbol=\'factorof\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="binary"> <xsl:with-param name="mo"><m:mo>|</m:mo></xsl:with-param> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="this-p" select="3"/> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:int]] |m:apply[*[1][self::m:csymbol=\'int\']] |m:bind[*[1][self::m:csymbol=\'int\']]"> <m:mrow> <m:msubsup> <m:mi>&#8747;</m:mi> <m:mrow><xsl:apply-templates  select="m:lowlimit/*|m:interval/*[1]|m:condition/*|m:domainofapplication/*"/></m:mrow> <m:mrow><xsl:apply-templates  select="m:uplimit/*|m:interval/*[2]"/></m:mrow> </m:msubsup> <xsl:apply-templates  select="*[last()]"/> <xsl:if test="m:bvar"> <m:mo>d</m:mo><xsl:apply-templates  select="m:bvar"/> </xsl:if> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:diff] and m:ci and count(*)=2]" priority="2"> <m:msup> <m:mrow><xsl:apply-templates  select="*[2]"/></m:mrow> <m:mo>&#8242;</m:mo> </m:msup> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:diff]]" priority="1"> <m:mfrac> <xsl:choose> <xsl:when test="m:bvar/m:degree"> <m:mrow><m:msup><m:mo>d</m:mo><xsl:apply-templates  select="m:bvar/m:degree/node()"/></m:msup> <xsl:apply-templates  select="*[last()]"/></m:mrow> <m:mrow><m:mo>d</m:mo><m:msup><xsl:apply-templates  select="m:bvar/node()"/><xsl:apply-templates  select="m:bvar/m:degree/node()"/></m:msup> </m:mrow> </xsl:when> <xsl:otherwise> <m:mrow><m:mo>d</m:mo><xsl:apply-templates  select="*[last()]"/></m:mrow> <m:mrow><m:mo>d</m:mo><xsl:apply-templates  select="m:bvar"/></m:mrow> </xsl:otherwise> </xsl:choose> </m:mfrac> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:partialdiff] and m:list and m:ci and count(*)=3]" priority="2"> <m:mrow> <m:msub><m:mo>D</m:mo><m:mrow> <xsl:for-each select="m:list[1]/*"> <xsl:apply-templates  select="."/> <xsl:if test="position()&lt;last()"><m:mo>,</m:mo></xsl:if> </xsl:for-each> </m:mrow></m:msub> <m:mrow><xsl:apply-templates  select="*[3]"/></m:mrow> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:partialdiff]]" priority="1"> <m:mfrac> <m:mrow> <xsl:choose> <xsl:when test="not(m:bvar/m:degree) and not(m:bvar[2])"> <m:mo>&#8706;</m:mo> </xsl:when> <xsl:otherwise> <m:msup><m:mo>&#8706;</m:mo> <m:mrow> <xsl:choose> <xsl:when test="m:degree"> <xsl:apply-templates  select="m:degree/node()"/> </xsl:when> <xsl:when test="m:bvar/m:degree[string(number(.))=\'NaN\']"> <xsl:for-each select="m:bvar/m:degree"> <xsl:apply-templates  select="node()"/> <xsl:if test="position()&lt;last()"><m:mo>+</m:mo></xsl:if> </xsl:for-each> <xsl:if test="count(m:bvar[not(m:degree)])&gt;0"> <m:mo>+</m:mo><m:mn><xsl:value-of select="count(m:bvar[not(m:degree)])"/></m:mn> </xsl:if> </xsl:when> <xsl:otherwise> <m:mn><xsl:value-of select="sum(m:bvar/m:degree)+count(m:bvar[not(m:degree)])"/></m:mn> </xsl:otherwise> </xsl:choose> </m:mrow> </m:msup> </xsl:otherwise> </xsl:choose> <xsl:apply-templates  select="*[last()]"/></m:mrow> <m:mrow> <xsl:for-each select="m:bvar"> <m:mrow> <m:mo>&#8706;</m:mo><m:msup><xsl:apply-templates  select="node()"/> <m:mrow><xsl:apply-templates  select="m:degree/node()"/></m:mrow> </m:msup> </m:mrow> </xsl:for-each> </m:mrow> </m:mfrac> </xsl:template> <xsl:template  match="m:lowlimit"/> <xsl:template  match="m:uplimit"/> <xsl:template  match="m:bvar"> <m:mi><xsl:apply-templates /></m:mi> <xsl:if test="following-sibling::m:bvar"><m:mo>,</m:mo></xsl:if> </xsl:template> <xsl:template  match="m:degree"/> <xsl:template  match="m:divergence"> <m:mo>div</m:mo> </xsl:template> <xsl:template  match="m:grad"> <m:mo>grad</m:mo> </xsl:template> <xsl:template  match="m:curl"> <m:mo>curl</m:mo> </xsl:template> <xsl:template  match="m:laplacian"> <m:msup><m:mo>&#8711;</m:mo><m:mn>2</m:mn></m:msup> </xsl:template> <xsl:template  match="m:set"> <xsl:call-template name="set"/> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:csymbol=\'set\']]"> <m:mfenced open="{{" close="}}" separators=","> <xsl:apply-templates  select="*[position()!=1]"/> </m:mfenced> </xsl:template> <xsl:template  match="m:list"> <xsl:call-template name="set"> <xsl:with-param name="o" select="\'(\'"/> <xsl:with-param name="c" select="\')\'"/> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:csymbol=\'list\']]"> <m:mfenced open="(" close=")" separators=","> <xsl:apply-templates  select="*[position()!=1]"/> </m:mfenced> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:union]] |m:apply[*[1][self::m:csymbol=\'union\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="2"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8746;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:intersect]] |m:apply[*[1][self::m:csymbol=\'intersect\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="3"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8745;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:in]] |m:apply[*[1][self::m:csymbol=\'in\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="binary"> <xsl:with-param name="mo"><m:mo>&#8712;</m:mo></xsl:with-param> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="this-p" select="3"/> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:notin]] |m:apply[*[1][self::m:csymbol=\'notin\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="binary"> <xsl:with-param name="mo"><m:mo>&#8713;</m:mo></xsl:with-param> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="this-p" select="3"/> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:subset]] |m:apply[*[1][self::m:csymbol=\'subset\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="2"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8838;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:prsubset]] |m:apply[*[1][self::m:csymbol=\'prsubset\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="2"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8834;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:notsubset]] |m:apply[*[1][self::m:csymbol=\'notsubset\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="binary"> <xsl:with-param name="this-p" select="2"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8840;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:notprsubset]] |m:apply[*[1][self::m:csymbol=\'notprsubset\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="binary"> <xsl:with-param name="this-p" select="2"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8836;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:setdiff]] |m:apply[*[1][self::m:csymbol=\'setdiff\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="binary"> <xsl:with-param name="this-p" select="2"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#8726;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:card]] |m:apply[*[1][self::m:csymbol=\'card\']]"> <m:mrow> <m:mo>|</m:mo> <xsl:apply-templates  select="*[2]"/> <m:mo>|</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:cartesianproduct or self::m:vectorproduct]] |m:apply[*[1][self::m:csymbol[.=\'cartesian_product\' or . = \'vectorproduct\']]]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="2"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#215;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template match="m:apply[*[1][self::m:cartesianproduct][count(following-sibling::m:reals)=count(following-sibling::*)]]" priority="2"> <m:msup> <xsl:apply-templates  select="*[2]"> <xsl:with-param name="p" select="5"/> </xsl:apply-templates> <m:mn><xsl:value-of select="count(*)-1"/></m:mn> </m:msup> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:sum]] |m:apply[*[1][self::m:csymbol=\'sum\']]"> <m:mrow> <m:msubsup> <m:mo>&#8721;</m:mo> <m:mrow><xsl:apply-templates  select="m:lowlimit|m:interval/*[1]|m:condition/*"/></m:mrow> <m:mrow><xsl:apply-templates  select="m:uplimit/*|m:interval/*[2]"/></m:mrow> </m:msubsup> <xsl:apply-templates  select="*[last()]"/> </m:mrow> </xsl:template> <xsl:template  match="m:apply/m:lowlimit" priority="3"> <m:mrow> <xsl:if test="../m:bvar"> <xsl:apply-templates  select="../m:bvar/node()"/> <m:mo>=</m:mo> </xsl:if> <xsl:apply-templates /> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:product]] |m:apply[*[1][self::m:csymbol=\'product\']]"> <m:mrow> <m:msubsup> <m:mo>&#8719;</m:mo> <m:mrow><xsl:apply-templates  select="m:lowlimit|m:interval/*[1]|m:condition/*"/></m:mrow> <m:mrow><xsl:apply-templates  select="m:uplimit/*|m:interval/*[2]"/></m:mrow> </m:msubsup> <xsl:apply-templates  select="*[last()]"/> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:limit]] |m:apply[*[1][self::m:csymbol=\'limit\']]"> <m:mrow> <m:munder> <m:mi>lim</m:mi> <m:mrow><xsl:apply-templates  select="m:lowlimit|m:condition/*"/></m:mrow> </m:munder> <xsl:apply-templates  select="*[last()]"/> </m:mrow> </xsl:template> <xsl:template  match="m:apply[m:limit]/m:lowlimit" priority="4"> <m:mrow> <xsl:apply-templates  select="../m:bvar/node()"/> <m:mo>&#8594;</m:mo> <xsl:apply-templates /> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:tendsto]]|m:reln[*[1][self::m:tendsto]]"> <xsl:param name="p"/> <xsl:call-template name="binary"> <xsl:with-param name="this-p" select="2"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo> <xsl:choose> <xsl:when test="@type=\'above\'">&#8600;</xsl:when> <xsl:when test="@type=\'below\'">&#8599;</xsl:when> <xsl:when test="@type=\'two-sided\'">&#8594;</xsl:when> <xsl:otherwise>&#8594;</xsl:otherwise> </xsl:choose> </m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:csymbol=\'tendsto\']]"> <m:mrow> <xsl:apply-templates  select="*[3]"/> <m:mo> <xsl:choose> <xsl:when test="*[1][self::above]">&#8600;</xsl:when> <xsl:when test="*[1][self::below]">&#8599;</xsl:when> <xsl:when test="*[1][self::two-sided]">&#8594;</xsl:when> <xsl:otherwise>&#8594;</xsl:otherwise> </xsl:choose> </m:mo> <xsl:apply-templates  select="*[4]"/> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][ self::m:sin or self::m:cos or self::m:tan or self::m:sec or self::m:csc or self::m:cot or self::m:sinh or self::m:cosh or self::m:tanh or self::m:sech or self::m:csch or self::m:coth or self::m:arcsin or self::m:arccos or self::m:arctan or self::m:arccosh or self::m:arccot or self::m:arccoth or self::m:arccsc or self::m:arccsch or self::m:arcsec or self::m:arcsech or self::m:arcsinh or self::m:arctanh or self::m:ln]]"> <m:mrow> <m:mi><xsl:value-of select="local-name(*[1])"/></m:mi> <xsl:apply-templates  select="*[2]"> <xsl:with-param name="p" select="7"/> </xsl:apply-templates> </m:mrow> </xsl:template> <xsl:template  match=" m:sin | m:cos | m:tan | m:sec | m:csc | m:cot | m:sinh | m:cosh | m:tanh | m:sech | m:csch | m:coth | m:arcsin | m:arccos | m:arctan | m:arccosh | m:arccot | m:arccoth | m:arccsc | m:arccsch | m:arcsec | m:arcsech | m:arcsinh | m:arctanh | m:ln"> <m:mi><xsl:value-of select="local-name()"/></m:mi> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:exp]] |m:apply[*[1][self::m:csymbol=\'exp\']]"> <m:msup> <m:mi>e</m:mi> <m:mrow><xsl:apply-templates  select="*[2]"/></m:mrow> </m:msup> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:log]] |m:apply[*[1][self::m:csymbol=\'log\']]"> <m:mrow> <xsl:choose> <xsl:when test="not(m:logbase) or m:logbase=10"> <m:mi>log</m:mi> </xsl:when> <xsl:otherwise> <m:msub> <m:mi>log</m:mi> <m:mrow><xsl:apply-templates  select="m:logbase/node()"/></m:mrow> </m:msub> </xsl:otherwise> </xsl:choose> <xsl:apply-templates  select="*[last()]"> <xsl:with-param name="p" select="7"/> </xsl:apply-templates> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:mean]] |m:apply[*[1][self::m:csymbol=\'mean\']]"> <m:mrow> <m:mo>&#9001;</m:mo> <xsl:for-each select="*[position()&gt;1]"> <xsl:apply-templates  select="."/> <xsl:if test="position() !=last()"><m:mo>,</m:mo></xsl:if> </xsl:for-each> <m:mo>&#9002;</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:sdev"> <m:mo>&#963;</m:mo> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:variance]] |m:apply[*[1][self::m:csymbol=\'variance\']]"> <m:msup> <m:mrow> <m:mo>&#963;</m:mo> <m:mo>(</m:mo> <xsl:apply-templates  select="*[2]"/> <m:mo>)</m:mo> </m:mrow> <m:mn>2</m:mn> </m:msup> </xsl:template> <xsl:template  match="m:median"> <m:mo>median</m:mo> </xsl:template> <xsl:template  match="m:mode"> <m:mo>mode</m:mo> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:moment]] |m:apply[*[1][self::m:csymbol=\'moment\']]"> <m:mrow> <m:mo>&#9001;</m:mo> <m:msup> <xsl:apply-templates  select="*[last()]"/> <m:mrow><xsl:apply-templates  select="m:degree/node()"/></m:mrow> </m:msup> <m:mo>&#9002;</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:momentabout"/> <xsl:template  match="m:apply[*[1][self::m:moment]][m:momentabout]" priority="2"> <m:msub> <m:mrow> <m:mo>&#9001;</m:mo> <m:msup> <xsl:apply-templates  select="*[last()]"/> <m:mrow><xsl:apply-templates  select="m:degree/node()"/></m:mrow> </m:msup> <m:mo>&#9002;</m:mo> </m:mrow> <m:mrow> <xsl:apply-templates  select="m:momentabout/*"/> </m:mrow> </m:msub> </xsl:template> <xsl:template  match="m:vector"> <m:mrow> <m:mo>(</m:mo> <m:mtable> <xsl:for-each select="*"> <m:mtr><m:mtd><xsl:apply-templates  select="."/></m:mtd></m:mtr> </xsl:for-each> </m:mtable> <m:mo>)</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:csymbol=\'vector\']]"> <m:mrow> <m:mo>(</m:mo> <m:mtable> <xsl:for-each select="*[position()!=1]"> <m:mtr> <m:mtd><xsl:apply-templates  select="."/></m:mtd> </m:mtr> </xsl:for-each> </m:mtable> <m:mo>)</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:matrix"> <m:mrow> <m:mo>(</m:mo> <m:mtable> <xsl:apply-templates /> </m:mtable> <m:mo>)</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:csymbol=\'matrix\']]"> <m:mrow> <m:mo>(</m:mo> <m:mtable> <xsl:apply-templates  select="*[position()!=1]"/> </m:mtable> <m:mo>)</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:matrixrow"> <m:mtr> <xsl:for-each select="*"> <m:mtd><xsl:apply-templates  select="."/></m:mtd> </xsl:for-each> </m:mtr> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:csymbol.=\'matrixrow\']]"> <m:mtr> <xsl:for-each select="*[position()!=1]"> <m:mtd><xsl:apply-templates  select="."/></m:mtd> </xsl:for-each> </m:mtr> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:determinant]] |m:apply[*[1][self::m:csymbol=\'determinant\']]"> <m:mrow> <m:mi>det</m:mi> <xsl:apply-templates  select="*[2]"> <xsl:with-param name="p" select="7"/> </xsl:apply-templates> </m:mrow> </xsl:template> <xsl:template match="m:apply[*[1][self::m:determinant]][*[2][self::m:matrix]]" priority="2"> <m:mrow> <m:mo>|</m:mo> <m:mtable> <xsl:apply-templates  select="m:matrix/*"/> </m:mtable> <m:mo>|</m:mo> </m:mrow> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:transpose]] |m:apply[*[1][self::m:csymbol=\'transpose\']]"> <m:msup> <xsl:apply-templates  select="*[2]"> <xsl:with-param name="p" select="7"/> </xsl:apply-templates> <m:mi>T</m:mi> </m:msup> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:selector]] |m:apply[*[1][self::m:csymbol=\'selector\']]"> <m:msub> <xsl:apply-templates  select="*[2]"> <xsl:with-param name="p" select="7"/> </xsl:apply-templates> <m:mrow> <xsl:for-each select="*[position()&gt;2]"> <xsl:apply-templates  select="."/> <xsl:if test="position() !=last()"><m:mo>,</m:mo></xsl:if> </xsl:for-each> </m:mrow> </m:msub> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:scalarproduct]] |m:apply[*[1][self::m:csymbol=\'scalarproduct\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="2"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>.</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:apply[*[1][self::m:outerproduct]] |m:apply[*[1][self::m:csymbol=\'outerproduct\']]"> <xsl:param name="p" select="0"/> <xsl:call-template name="infix"> <xsl:with-param name="this-p" select="2"/> <xsl:with-param name="p" select="$p"/> <xsl:with-param name="mo"><m:mo>&#x2297;</m:mo></xsl:with-param> </xsl:call-template> </xsl:template> <xsl:template  match="m:semantics"> <xsl:apply-templates  select="*[1]"/> </xsl:template> <xsl:template  match="m:semantics[m:annotation-xml/@encoding=\'MathML-Presentation\']"> <xsl:apply-templates  select="m:annotation-xml[@encoding=\'MathML-Presentation\']/node()"/> </xsl:template> <xsl:template  match="m:integers"> <m:mi mathvariant="double-struck">Z</m:mi> </xsl:template> <xsl:template  match="m:reals"> <m:mi mathvariant="double-struck">R</m:mi> </xsl:template> <xsl:template  match="m:rationals"> <m:mi mathvariant="double-struck">Q</m:mi> </xsl:template> <xsl:template  match="m:naturalnumbers"> <m:mi mathvariant="double-struck">N</m:mi> </xsl:template> <xsl:template  match="m:complexes"> <m:mi mathvariant="double-struck">C</m:mi> </xsl:template> <xsl:template  match="m:primes"> <m:mi mathvariant="double-struck">P</m:mi> </xsl:template> <xsl:template  match="m:exponentiale"> <m:mi>e</m:mi> </xsl:template> <xsl:template  match="m:imaginaryi"> <m:mi>i</m:mi> </xsl:template> <xsl:template  match="m:notanumber"> <m:mi>NaN</m:mi> </xsl:template> <xsl:template  match="m:true"> <m:mi>true</m:mi> </xsl:template> <xsl:template  match="m:false"> <m:mi>false</m:mi> </xsl:template> <xsl:template  match="m:emptyset|m:csymbol[.=\'emptyset\']"> <m:mi>&#8709;</m:mi> </xsl:template> <xsl:template  match="m:pi|m:csymbol[.=\'pi\']"> <m:mi>&#960;</m:mi> </xsl:template> <xsl:template  match="m:eulergamma|m:csymbol[.=\'gamma\']"> <m:mi>&#947;</m:mi> </xsl:template> <xsl:template  match="m:infinity|m:csymbol[.=\'infinity\']"> <m:mi>&#8734;</m:mi> </xsl:template> <xsl:template name="infix" > <xsl:param name="mo"/> <xsl:param name="p" select="0"/> <xsl:param name="this-p" select="0"/> <m:mrow> <xsl:if test="$this-p &lt; $p"><m:mo>(</m:mo></xsl:if> <xsl:for-each select="*[position()&gt;1]"> <xsl:if test="position() &gt; 1"> <xsl:copy-of select="$mo"/> </xsl:if> <xsl:apply-templates  select="."> <xsl:with-param name="p" select="$this-p"/> </xsl:apply-templates> </xsl:for-each> <xsl:if test="$this-p &lt; $p"><m:mo>)</m:mo></xsl:if> </m:mrow> </xsl:template> <xsl:template name="binary" > <xsl:param name="mo"/> <xsl:param name="p" select="0"/> <xsl:param name="this-p" select="0"/> <m:mrow> <xsl:if test="$this-p &lt; $p"><m:mo>(</m:mo></xsl:if> <xsl:apply-templates  select="*[2]"> <xsl:with-param name="p" select="$this-p"/> </xsl:apply-templates> <xsl:copy-of select="$mo"/> <xsl:apply-templates  select="*[3]"> <xsl:with-param name="p" select="$this-p"/> </xsl:apply-templates> <xsl:if test="$this-p &lt; $p"><m:mo>)</m:mo></xsl:if> </m:mrow> </xsl:template> <xsl:template name="set" > <xsl:param name="o" select="\'{\'"/> <xsl:param name="c" select="\'}\'"/> <m:mrow> <m:mo><xsl:value-of select="$o"/></m:mo> <xsl:choose> <xsl:when test="m:condition"> <m:mrow><xsl:apply-templates  select="m:bvar/*[not(self::m:bvar or self::m:condition)]"/></m:mrow> <m:mo>|</m:mo> <m:mrow><xsl:apply-templates  select="m:condition/node()"/></m:mrow> </xsl:when> <xsl:otherwise> <xsl:for-each select="*[not(position()=1 and parent::m:apply)]"> <xsl:apply-templates  select="."/> <xsl:if test="position() !=last()"><m:mo>,</m:mo></xsl:if> </xsl:for-each> </xsl:otherwise> </xsl:choose> <m:mo><xsl:value-of select="$c"/></m:mo> </m:mrow> </xsl:template><xsl:template match="*[@dir=\'rtl\']" ><xsl:copy><xsl:apply-templates select="@*|node()" mode="rtl"/></xsl:copy></xsl:template><xsl:template match="@*" mode="rtl"><xsl:copy-of select="."/></xsl:template><xsl:template match="*" mode="rtl"><xsl:copy><xsl:apply-templates select="@*" mode="rtl"/><xsl:apply-templates  mode="rtl"><xsl:sort data-type="number" order="descending" select="position()"/></xsl:apply-templates></xsl:copy></xsl:template><xsl:template match="m:mtable|m:munder|m:over|m:munderover" mode="rtl" priority="2"><xsl:copy><xsl:apply-templates select="@*" mode="rtl"/><xsl:apply-templates  mode="rtl"></xsl:apply-templates></xsl:copy></xsl:template><xsl:template match="m:msup" mode="rtl" priority="2"><m:mmultiscripts><xsl:apply-templates select="*[1]" mode="rtl"/><m:mprescripts/><m:none/><xsl:apply-templates select="*[2]" mode="rtl"/></m:mmultiscripts></xsl:template><xsl:template match="m:msub" mode="rtl" priority="2"><m:mmultiscripts><xsl:apply-templates select="*[1]" mode="rtl"/><m:mprescripts/><xsl:apply-templates select="*[2]" mode="rtl"/><m:none/></m:mmultiscripts></xsl:template><xsl:template match="m:msubsup" mode="rtl" priority="2"><m:mmultiscripts><xsl:apply-templates select="*[1]" mode="rtl"/><m:mprescripts/><xsl:apply-templates select="*[2]" mode="rtl"/><xsl:apply-templates select="*[3]" mode="rtl"/></m:mmultiscripts></xsl:template><xsl:template match="m:mmultiscripts" mode="rtl" priority="2"><m:mmultiscripts><xsl:apply-templates select="*[1]" mode="rtl"/><xsl:apply-templates select="m:mprescripts/following-sibling::*" mode="rtl"><xsl:sort data-type="number" order="descending" select="position()"/></xsl:apply-templates><m:mprescripts/><xsl:apply-templates select="m:mprescripts/preceding-sibling::*[position()!=last()]" mode="rtl"><xsl:sort data-type="number" order="descending" select="position()"/></xsl:apply-templates></m:mmultiscripts></xsl:template><xsl:template match="text()[.=\'(\']" mode="rtl">)</xsl:template><xsl:template match="text()[.=\')\']" mode="rtl">(</xsl:template><xsl:template match="text()[.=\'{\']" mode="rtl">}</xsl:template><xsl:template match="text()[.=\'}\']" mode="rtl">{</xsl:template><xsl:template match="text()[.=\'&lt;\']" mode="rtl">&gt;</xsl:template><xsl:template match="text()[.=\'&gt;\']" mode="rtl">&lt;</xsl:template><xsl:template match="text()[.=\'&#x2208;\']" mode="rtl">&#x220b;</xsl:template><xsl:template match="text()[.=\'&#x220b;\']" mode="rtl">&#x2208;</xsl:template><xsl:template match="text()[.=\'&#x2211;\']|text()[.=\'&#x222b;\']" mode="rtl"><svg width="20" height="20"  version="1.1" xmlns="http://www.w3.org/2000/svg"><g transform="matrix(-1 0 0 1 0 0 )"><text id="TextElement" x="-20" y="15" ><xsl:value-of select="."/></text></g></svg></xsl:template></xsl:stylesheet>', "text/xml");

window.addEventListener("load", function(e) {

if(document.getElementsByTagNameNS('http://www.w3.org/1998/Math/MathML','math').length > 0) {
//alert("Content mathml is here");

 var proc = new XSLTProcessor();
    proc.importStylesheet(xslt);
var newdocument=proc.transformToDocument(document);
// var dataString = (new XMLSerializer()).serializeToString(newdocument);
//alert(dataString);
//alert("Content mathml is now presentation");


document.getElementsByTagNameNS("http://www.w3.org/1999/xhtml","html")[0].replaceChild(newdocument.getElementsByTagNameNS("http://www.w3.org/1999/xhtml","body")[0],document.getElementsByTagNameNS("http://www.w3.org/1999/xhtml","body")[0]);

}
else {
// alert("Content mathml is NOT  here")
}

}, false);

