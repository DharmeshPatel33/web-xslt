/*
 *  /MathJax/extensions/MathML/content-mathml.js
 *
 *  Copyright (c) 2009-2013 The MathJax Consortium
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

MathJax.Extension["MathML/content-mathml"]={version:"2.3"};MathJax.Hub.Register.StartupHook("MathML Jax Ready",function(){var c=MathJax.InputJax.MathML,e=c.Parse.prototype;c.prefilterHooks.Add(function(h){if(!c.ctopXSLT){return}if(!c.ParseXML){c.ParseXML=c.createParser()}var i=c.ParseXML(e.preProcessMath(h.math));var g=c.ctopXSLT.transformToDocument(i);if((typeof g)==="string"){h.math=g}else{if(window.XMLSerializer){var f=new XMLSerializer();h.math=f.serializeToString(g.documentElement,i)}}});var a='<x:stylesheet version="1.0" xmlns:x="http://www.w3.org/1999/XSL/Transform" xmlns="http://www.w3.org/1998/Math/MathML" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:e="http://exslt.org/strings"  xmlns:c="http://exslt.org/common" exclude-result-prefixes="m e c">  <!--  Copyright David Carlisle 2001, 2002, 2008, 2009, 2013.  Use and distribution of this code are permitted under the terms of the<a href="http://www.w3.org/Consortium/Legal/copyright-software-19980720" >W3C Software Notice and License</a>. Or the Apache 2, MIT or MPL 1.1 or MPL 2.0 licences. 2001-2002 MathML2 version 2008-2009     Updates for MathML3 --> <x:output method="xml" /> <x:template match="/"><x:apply-templates/></x:template> <x:template match="*"><x:copy><x:copy-of select="@*"/><x:apply-templates/></x:copy></x:template>    <x:template match="m:cn"><mn><x:apply-templates/></mn></x:template> <x:template match="m:cn[@type=\'complex-cartesian\']"><mrow><mn><x:apply-templates select="text()[1]"/></mn><mo>+</mo><mn><x:apply-templates select="text()[2]"/></mn><mo>&#8290;</mo><mi>i</mi></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'complex_cartesian\']]"><mrow><mn><x:apply-templates select="*[2]"/></mn><mo>+</mo><mn><x:apply-templates select="*[3]"/></mn><mo>&#8290;</mo><mi>i</mi></mrow></x:template> <x:template match="m:cn[@type=\'rational\']"><mrow><mn><x:apply-templates select="text()[1]"/></mn><mo>/</mo><mn><x:apply-templates select="text()[2]"/></mn></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'rational\']]"><mrow><mn><x:apply-templates select="*[2]"/></mn><mo>/</mo><mn><x:apply-templates select="*[3]"/></mn></mrow></x:template> <x:template match="m:cn[not(@type) or @type=\'integer\']"><x:choose><x:when test="not(@base) or @base=10"><mn><x:apply-templates/></mn></x:when><x:otherwise><msub><mn><x:apply-templates/></mn><mn><x:value-of select="@base"/></mn></msub></x:otherwise></x:choose></x:template> <x:template match="m:cn[@type=\'complex-polar\']"><mrow><mn><x:apply-templates select="text()[1]"/></mn><mo>&#8290;</mo><msup><mi>e</mi><mrow><mi>i</mi><mo>&#8290;</mo><mn><x:apply-templates select="text()[2]"/></mn></mrow></msup></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'complex_polar\']]"><mrow><x:apply-templates select="*[2]"/><mo>&#8290;</mo><msup><mi>e</mi><mrow><mi>i</mi><mo>&#8290;</mo><x:apply-templates select="*[3]"/></mrow></msup></mrow></x:template> <x:template match="m:cn[@type=\'e-notation\']"><mn><x:apply-templates select="m:sep/preceding-sibling::node()"/><x:text>E</x:text><x:apply-templates select="m:sep/following-sibling::node()"/></mn></x:template> <x:template match="m:cn[@type=\'hexdouble\']"><mn><x:text>0x</x:text><x:apply-templates/></mn></x:template>   <x:template match="m:ci/text()"><mi><x:value-of select="."/></mi></x:template> <x:template match="m:ci"><mrow><x:apply-templates/></mrow></x:template>   <x:template match="m:csymbol/text()"><mi><x:value-of select="."/></mi></x:template> <x:template match="m:csymbol"><mrow><x:apply-templates/></mrow></x:template>   <x:template match="m:apply|m:reln"><mrow><x:choose><x:when test="*[1]/*/*"><mfenced separators=""><x:apply-templates select="*[1]"><x:with-param name="p" select="10"/></x:apply-templates></mfenced></x:when><x:otherwise><x:apply-templates select="*[1]"><x:with-param name="p" select="10"/></x:apply-templates></x:otherwise></x:choose><mo>&#8289;</mo><mfenced open="(" close=")" separators=","><x:apply-templates select="*[position()>1]"/></mfenced></mrow></x:template>  <x:template match="m:bind"><mrow><x:choose><x:when test="*[1]/*/*"><mfenced separators=""><x:apply-templates select="*[1]"><x:with-param name="p" select="10"/></x:apply-templates></mfenced></x:when><x:otherwise><x:apply-templates select="*[1]"><x:with-param name="p" select="10"/></x:apply-templates></x:otherwise></x:choose><x:apply-templates select="bvar/*"/><mo>.</mo><x:apply-templates select="*[position()>1][not(self::m:bvar)]"/></mrow></x:template>  <x:template match="m:fn"><mrow><x:apply-templates/></mrow></x:template>  <x:template match="m:interval[*[2]]"><mfenced open="[" close="]"><x:apply-templates/></mfenced></x:template><x:template match="m:interval[*[2]][@closure=\'open\']" priority="2"><mfenced open="(" close=")"><x:apply-templates/></mfenced></x:template><x:template match="m:interval[*[2]][@closure=\'open-closed\']" priority="2"><mfenced open="(" close="]"><x:apply-templates/></mfenced></x:template><x:template match="m:interval[*[2]][@closure=\'closed-open\']" priority="2"><mfenced open="[" close=")"><x:apply-templates/></mfenced></x:template> <x:template match="m:interval"><mfenced open="{{" close="}}"><x:apply-templates/></mfenced></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'integer_interval\']]"><mfenced open="[" close="]"><x:apply-templates select="*[position()!=1]"/></mfenced></x:template><x:template match="m:apply[*[1][self::m:csymbol=\'interval\']]"><mfenced open="[" close="]"><x:apply-templates select="*[position()!=1]"/></mfenced></x:template><x:template match="m:apply[*[1][self::m:csymbol=\'interval-cc\']]"><mfenced open="[" close="]"><x:apply-templates select="*[position()!=1]"/></mfenced></x:template><x:template match="m:apply[*[1][self::m:csymbol=\'interval-oo\']]"><mfenced open="(" close=")"><x:apply-templates select="*[position()!=1]"/></mfenced></x:template><x:template match="m:apply[*[1][self::m:csymbol=\'oriented_interval\']]"><mfenced open="(" close=")"><x:apply-templates select="*[position()!=1]"/></mfenced></x:template>   <x:template match="m:apply[*[1][self::m:inverse]] |m:apply[*[1][self::m:csymbol=\'inverse\']]"><msup><x:apply-templates select="*[2]"/><mrow><mo>(</mo><mn>-1</mn><mo>)</mo></mrow></msup></x:template>    <x:template match="m:condition"><mrow><x:apply-templates/></mrow></x:template>  <x:template match="m:declare"/>  <x:template match="m:lambda |m:apply[*[1][self::m:csymbol=\'lambda\']] |m:bind[*[1][self::m:csymbol=\'lambda\']]"><mrow><mi>&#955;</mi><mrow><x:apply-templates select="m:bvar/*"/></mrow><mo>.</mo><mfenced><x:apply-templates select="*[last()]"/></mfenced></mrow></x:template>   <x:template match="m:apply[*[1][self::m:compose]] |m:apply[*[1][self::m:csymbol=\'left_compose\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8728;</mo></x:with-param></x:call-template></x:template>   <x:template match="m:ident"><mi>id</mi></x:template>  <x:template match="m:domain"><mi>domain</mi></x:template>  <x:template match="m:codomain"><mi>codomain</mi></x:template>  <x:template match="m:image"><mi>image</mi></x:template>  <x:template match="m:domainofapplication"><merror><mtext>unexpected domainofapplication</mtext></merror></x:template> <x:template match="m:apply[*[2][self::m:bvar]][m:domainofapplication]" priority="0.4"><mrow><munder><x:apply-templates select="*[1]"/><mrow><x:apply-templates select="m:bvar/*"/><mo>&#8712;</mo><x:apply-templates select="m:domainofapplication/*"/></mrow></munder><mfenced><x:apply-templates select="m:domainofapplication/following-sibling::*"/></mfenced></mrow></x:template> <x:template match="m:apply[m:domainofapplication]" priority="0.3"><mrow><mrow><mi>restriction</mi><mfenced><x:apply-templates select="*[1]"/><x:apply-templates select="m:domainofapplication/*"/></mfenced></mrow><mfenced><x:apply-templates select="m:domainofapplication/following-sibling::*"/></mfenced></mrow></x:template>  <x:template match="m:piecewise"><mrow><mo>{</mo><mtable><x:for-each select="m:piece|m:otherwise"><mtr><mtd><x:apply-templates select="*[1]"/></mtd><x:choose><x:when  test="self::m:piece"><mtd columnalign="left"><mtext>&#160; if &#160;</mtext></mtd><mtd><x:apply-templates select="*[2]"/></mtd></x:when><x:otherwise><mtd colspan="2" columnalign="left"><mtext>&#160; otherwise</mtext></mtd></x:otherwise></x:choose></mtr></x:for-each></mtable></mrow></x:template>   <x:template match="m:apply[*[1][self::m:quotient]] |m:apply[*[1][self::m:csymbol=\'quotient\']]"><mrow><mo>&#8970;</mo><x:apply-templates select="*[2]"/><mo>/</mo><x:apply-templates select="*[3]"/><mo>&#8971;</mo></mrow></x:template>    <x:template match="m:apply[*[1][self::m:factorial]] |m:apply[*[1][self::m:csymbol=\'factorial\']]"><mrow><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates><mo>!</mo></mrow></x:template>   <x:template match="m:apply[*[1][self::m:divide]] |m:apply[*[1][self::m:csymbol=\'divide\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>/</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:max]] |m:apply[*[1][self::m:csymbol=\'max\']]"><mrow><mi>max</mi><x:call-template name="set"/></mrow></x:template> <x:template match="m:apply[*[1][self::m:min]]|m:reln[*[1][self::m:min]]"><mrow><mi>min</mi><x:call-template name="set"/></mrow></x:template>  <x:template match="m:apply[*[1][self::m:minus] and count(*)=2] |m:apply[*[1][self::m:csymbol=\'unary_minus\']]"><mrow><mo>&#8722;</mo><x:apply-templates select="*[2]"><x:with-param name="p" select="5"/></x:apply-templates></mrow></x:template> <x:template match="m:apply[*[1][self::m:minus] and count(*)&gt;2] |m:apply[*[1][self::m:csymbol=\'minus\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>&#8722;</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="2"/></x:call-template></x:template>  <!-- put out - on leading term (mathjax report)--><x:template match="m:apply[*[1][self::m:plus]] |m:apply[*[1][self::m:csymbol=\'plus\']]"><x:param name="p" select="0"/><mrow><x:if test="$p &gt; 2"><mo>(</mo></x:if><x:for-each select="*[position()&gt;1]"><x:choose><x:when test="self::m:apply[*[1][self::m:times] and *[2][self::m:apply/*[1][self::m:minus] or self::m:cn[not(m:sep) and (number(.) &lt; 0)]]]"><mo>&#8722;</mo></x:when><x:when test="position()!=1"><mo>+</mo></x:when></x:choose><x:choose><x:when test="self::m:apply[*[1][self::m:times] and *[2][self::m:cn[not(m:sep) and (number(.) &lt;0)]]]"><mrow><mn><x:value-of select="-(*[2])"/></mn><mo>&#8290;</mo><x:apply-templates select="."><x:with-param name="first" select="2"/><x:with-param name="p" select="2"/></x:apply-templates></mrow></x:when><x:when test="self::m:apply[*[1][self::m:times] and *[2][self::m:apply/*[1][self::m:minus]]]"><mrow><x:apply-templates select="./*[2]/*[2]"/><x:apply-templates select="."><x:with-param name="first" select="2"/><x:with-param name="p" select="2"/></x:apply-templates></mrow></x:when><x:otherwise><x:apply-templates select="."><x:with-param name="p" select="2"/></x:apply-templates></x:otherwise></x:choose></x:for-each><x:if test="$p &gt; 2"><mo>)</mo></x:if></mrow></x:template>   <x:template match="m:apply[*[1][self::m:power]] |m:apply[*[1][self::m:csymbol=\'power\']]"><x:param name="p" select="0"/><x:choose><x:when test="$p&gt;=5"><mrow><mo>(</mo><msup><x:apply-templates select="*[2]"><x:with-param name="p" select="5"/></x:apply-templates><x:apply-templates select="*[3]"><x:with-param name="p" select="5"/></x:apply-templates></msup><mo>)</mo></mrow></x:when><x:otherwise><msup><x:apply-templates select="*[2]"><x:with-param name="p" select="5"/></x:apply-templates><x:apply-templates select="*[3]"><x:with-param name="p" select="5"/></x:apply-templates></msup></x:otherwise></x:choose></x:template>  <x:template match="m:apply[*[1][self::m:rem]] |m:apply[*[1][self::m:csymbol=\'rem\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>mod</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:times]] |m:apply[*[1][self::m:csymbol=\'times\']]" name="times"><x:param name="p" select="0"/><x:param name="first" select="1"/><mrow><x:if test="$p &gt; 3"><mo>(</mo></x:if><x:for-each select="*[position()&gt;1]"><x:if test="position() &gt; 1"><mo><x:choose><x:when test="self::m:cn">&#215;</x:when><x:otherwise>&#8290;</x:otherwise></x:choose></mo></x:if><x:if test="position()&gt;= $first"><x:apply-templates select="."><x:with-param name="p" select="3"/></x:apply-templates></x:if></x:for-each><x:if test="$p &gt; 3"><mo>)</mo></x:if></mrow></x:template>   <x:template match="m:apply[*[1][self::m:root] and not(m:degree) or m:degree=2]" priority="4"><msqrt><x:apply-templates select="*[position()&gt;1]"/></msqrt></x:template> <x:template match="m:apply[*[1][self::m:root]]"><mroot><x:apply-templates select="*[position()&gt;1 and not(self::m:degree)]"/><mrow><x:apply-templates select="m:degree/*"/></mrow></mroot></x:template>  <x:template match="m:apply[*[1][self::m:csymbol=\'root\']]"><mroot><x:apply-templates select="*[position()!=1]"/></mroot></x:template>  <x:template match="m:gcd"><mi>gcd</mi></x:template>  <x:template match="m:apply[*[1][self::m:and]] |m:reln[*[1][self::m:and]] |m:apply[*[1][self::m:csymbol=\'and\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8743;</mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:or]] |m:apply[*[1][self::m:csymbol=\'or\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="3"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8744;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:xor]] |m:apply[*[1][self::m:csymbol=\'xor\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="3"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>xor</mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:not]] |m:apply[*[1][self::m:csymbol=\'not\']]"><mrow><mo>&#172;</mo><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates></mrow></x:template>     <x:template match="m:apply[*[1][self::m:implies]] |m:reln[*[1][self::m:implies]] |m:apply[*[1][self::m:csymbol=\'implies\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>&#8658;</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:forall]] |m:apply[*[1][self::m:csymbol=\'forall\']] |m:bind[*[1][self::m:forall]] |m:bind[*[1][self::m:csymbol=\'forall\']]"><mrow><mo>&#8704;</mo><mrow><x:apply-templates select="m:bvar[not(current()/m:condition)]/*|m:condition/*"/></mrow><mo>.</mo><mfenced><x:apply-templates select="*[last()]"/></mfenced></mrow></x:template>    <x:template match="m:apply[*[1][self::m:exists]] |m:apply[*[1][self::m:csymbol=\'exists\']] |m:bind[*[1][self::m:exists]] |m:bind[*[1][self::m:csymbol=\'exists\']]"><mrow><mo>&#8707;</mo><mrow><x:apply-templates select="m:bvar[not(current()/m:condition)]/*|m:condition/*"/></mrow><mo>.</mo><mfenced separators=""><x:choose><x:when test="m:condition"><x:apply-templates select="m:condition/*"/><mo>&#8743;</mo></x:when><x:when test="m:domainofapplication"><mrow><mrow><x:for-each select="m:bvar"><x:apply-templates/><x:if test="position()!=last()"><mo>,</mo></x:if></x:for-each></mrow><mo>&#8712;</mo><x:apply-templates select="m:domainofapplication/*"/></mrow><mo>&#8743;</mo></x:when></x:choose><x:apply-templates select="*[last()]"/></mfenced></mrow></x:template>    <x:template match="m:apply[*[1][self::m:abs]] |m:apply[*[1][self::m:csymbol=\'abs\']]"><mrow><mo>|</mo><x:apply-templates select="*[2]"/><mo>|</mo></mrow></x:template>    <x:template match="m:apply[*[1][self::m:conjugate]] |m:apply[*[1][self::m:csymbol=\'conjugate\']]"><mover><x:apply-templates select="*[2]"/><mo>&#175;</mo></mover></x:template>  <x:template match="m:arg"><mi>arg</mi></x:template>   <x:template match="m:real|m:csymbol[.=\'real\']"><mo>&#8475;</mo></x:template>  <x:template match="m:imaginary|m:csymbol[.=\'imaginary\']"><mo>&#8465;</mo></x:template>  <x:template match="m:lcm"><mi>lcm</mi></x:template>   <x:template match="m:apply[*[1][self::m:floor]] |m:apply[*[1][self::m:csymbol=\'floor\']]"><mrow><mo>&#8970;</mo><x:apply-templates select="*[2]"/><mo>&#8971;</mo></mrow></x:template>   <x:template match="m:apply[*[1][self::m:ceiling]] |m:apply[*[1][self::m:csymbol=\'ceiling\']]"><mrow><mo>&#8968;</mo><x:apply-templates select="*[2]"/><mo>&#8969;</mo></mrow></x:template>  <x:template match="m:apply[*[1][self::m:eq]] |m:reln[*[1][self::m:eq]] |m:apply[*[1][self::m:csymbol=\'eq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>=</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:neq]] |m:apply[*[1][self::m:csymbol=\'neq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8800;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:gt]] |m:reln[*[1][self::m:gt]] |m:apply[*[1][self::m:csymbol=\'gt\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&gt;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:lt]] |m:reln[*[1][self::m:lt]] |m:apply[*[1][self::m:csymbol=\'lt\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&lt;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:geq]] |m:apply[*[1][self::m:csymbol=\'geq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8805;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:leq]] |m:apply[*[1][self::m:csymbol=\'leq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8804;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:equivalent]] |m:apply[*[1][self::m:csymbol=\'equivalent\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8801;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:approx]] |m:apply[*[1][self::m:csymbol=\'approx\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8771;</mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:factorof]] |m:apply[*[1][self::m:csymbol=\'factorof\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>|</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:int]] |m:apply[*[1][self::m:csymbol=\'int\']] |m:bind[*[1][self::m:int]] |m:bind[*[1][self::m:csymbol=\'int\']]"><mrow><msubsup><mi>&#8747;</mi><mrow><x:apply-templates select="m:lowlimit/*|m:interval/*[1]|m:condition/*|m:domainofapplication/*"/></mrow><mrow><x:apply-templates select="m:uplimit/*|m:interval/*[2]"/></mrow></msubsup><x:apply-templates select="*[last()]"/><x:if test="m:bvar"><mi>d</mi><x:apply-templates select="m:bvar"/></x:if></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'defint\']]"><mrow><munder><mi>&#8747;</mi><x:apply-templates select="*[2]"/></munder><x:apply-templates select="*[last()]"/></mrow></x:template>  <x:template match="m:apply[*[1][self::m:diff] and not(m:bvar)]| m:apply[*[1][self::m:csymbol=\'diff\']]" priority="2"><msup><mrow><x:apply-templates select="*[2]"/></mrow><mo>&#8242;</mo></msup></x:template> <x:template match="m:apply[*[1][self::m:diff]]" priority="1"><mfrac><x:choose><x:when test="m:bvar/m:degree"><mrow><msup><mi>d</mi><x:apply-templates select="m:bvar/m:degree/node()"/></msup><x:apply-templates  select="*[last()]"/></mrow><mrow><mi>d</mi><msup><x:apply-templates select="m:bvar/node()"/><x:apply-templates select="m:bvar/m:degree/node()"/></msup></mrow></x:when><x:otherwise><mrow><mi>d</mi><x:apply-templates select="*[last()]"/></mrow><mrow><mi>d</mi><x:apply-templates select="m:bvar"/></mrow></x:otherwise></x:choose></mfrac></x:template>   <x:template match="m:apply[*[1][self::m:partialdiff] and m:list and m:ci and count(*)=3]" priority="2"><mrow><msub><mi>D</mi><mrow><x:for-each select="m:list[1]/*"><x:apply-templates select="."/><x:if test="position()&lt;last()"><mo>,</mo></x:if></x:for-each></mrow></msub><mrow><x:apply-templates select="*[3]"/></mrow></mrow></x:template> <x:template match="m:apply[*[1][self::m:partialdiff]]" priority="1"><mfrac><mrow><x:choose><x:when test="not(m:bvar/m:degree) and not(m:bvar[2])"><mo>&#8706;</mo></x:when><x:otherwise><msup><mo>&#8706;</mo><mrow><x:choose><x:when test="m:degree"><x:apply-templates select="m:degree/node()"/></x:when><x:when test="m:bvar/m:degree[string(number(.))=\'NaN\']"><x:for-each select="m:bvar/m:degree"><x:apply-templates select="node()"/><x:if test="position()&lt;last()"><mo>+</mo></x:if></x:for-each><x:if test="count(m:bvar[not(m:degree)])&gt;0"><mo>+</mo><mn><x:value-of select="count(m:bvar[not(m:degree)])"/></mn></x:if></x:when><x:otherwise><mn><x:value-of select="number(sum(m:bvar/m:degree))+count(m:bvar[not(m:degree)])"/></mn></x:otherwise></x:choose></mrow></msup></x:otherwise></x:choose><x:apply-templates  select="*[last()]"/></mrow><mrow><x:for-each select="m:bvar"><mrow><mo>&#8706;</mo><msup><x:apply-templates select="node()"/><mrow><x:apply-templates select="m:degree/node()"/></mrow></msup></mrow></x:for-each></mrow></mfrac></x:template>  <x:template match="m:apply[*[1][self::m:csymbol=\'partialdiffdegree\']]"><mrow><msub><mo>&#8706;</mo><mrow><x:apply-templates select="*[2]"/></mrow></msub><mfenced><x:apply-templates select="*[4]"/></mfenced></mrow></x:template>   <x:template match="m:lowlimit"/>  <x:template match="m:uplimit"/>  <x:template match="m:bvar"><mi><x:apply-templates/></mi><x:if test="following-sibling::m:bvar"><mo>,</mo></x:if></x:template>  <x:template match="m:degree"/>  <x:template match="m:divergence"><mi>div</mi></x:template> <x:template match="m:apply[*[1][self::m:divergence]and m:bvar and m:vector]"><x:variable name="v" select="m:bvar"/><mrow><mi>div</mi><mo>&#8289;</mo><mo>(</mo><mtable><x:for-each select="m:vector/*"><x:variable name="p" select="position()"/><mtr><mtd><x:apply-templates select="$v[$p]/*"/><mo>&#x21a6;</mo><x:apply-templates select="."/></mtd></mtr></x:for-each></mtable><mo>)</mo></mrow></x:template>  <x:template match="m:grad"><mi>grad</mi></x:template> <x:template match="m:apply[*[1][self::m:grad]and m:bvar]"><mrow><mi>grad</mi><mo>&#8289;</mo><mrow><mo>(</mo><mfenced><x:apply-templates select="m:bvar/*"/></mfenced><mo>&#x21a6;</mo><x:apply-templates select="*[position()!=1][not(self::m:bvar)]"/><mo>)</mo></mrow></mrow></x:template>  <x:template match="m:curl"><mi>curl</mi></x:template>   <x:template match="m:laplacian"><msup><mo>&#8711;</mo><mn>2</mn></msup></x:template> <x:template match="m:apply[*[1][self::m:laplacian]and m:bvar]"><mrow><x:apply-templates select="*[1]"/><mo>&#8289;</mo><mrow><mo>(</mo><mfenced><x:apply-templates select="m:bvar/*"/></mfenced><mo>&#x21a6;</mo><x:apply-templates select="*[position()!=1][not(self::m:bvar)]"/><mo>)</mo></mrow></mrow></x:template>   <x:template match="m:set"><x:call-template name="set"/></x:template> <x:template  match="m:apply[*[1][self::m:csymbol=\'set\']]"><mfenced open="{{" close="}}" separators=","><x:apply-templates select="*[position()!=1]"/></mfenced></x:template>   <x:template match="m:list"><x:call-template name="set"><x:with-param name="o" select="\'(\'"/><x:with-param name="c" select="\')\'"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:csymbol=\'list\']]"><mfenced open="(" close=")" separators=","><x:apply-templates select="*[position()!=1]"/></mfenced></x:template>  <x:template match="m:apply[*[1][self::m:union]] |m:apply[*[1][self::m:csymbol=\'union\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8746;</mo></x:with-param></x:call-template></x:template> <x:template match="m:apply[*[1][self::m:union]][m:bvar] |m:apply[*[1][self::m:csymbol=\'union\']][m:bvar]" priority="2" ><x:call-template name="sum"><x:with-param name="mo"><mo>&#x22C3;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:intersect]] |m:apply[*[1][self::m:csymbol=\'intersect\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="3"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8745;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:intersect]][m:bvar] |m:apply[*[1][self::m:csymbol=\'intersect\']][m:bvar]" priority="2" ><x:call-template name="sum"><x:with-param name="mo"><mo>&#x22C2;</mo></x:with-param></x:call-template></x:template>    <x:template match="m:apply[*[1][self::m:in]] |m:apply[*[1][self::m:csymbol=\'in\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>&#8712;</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:notin]]|m:reln[*[1][self::m:notin]] |m:apply[*[1][self::m:csymbol=\'notin\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>&#8713;</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:subset]] |m:apply[*[1][self::m:csymbol=\'subset\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8838;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:prsubset]] |m:apply[*[1][self::m:csymbol=\'prsubset\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8834;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:notsubset]] |m:apply[*[1][self::m:csymbol=\'notsubset\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8840;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:notprsubset]] |m:apply[*[1][self::m:csymbol=\'notprsubset\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8836;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:setdiff]] |m:apply[*[1][self::m:csymbol=\'setdiff\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8726;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:card]] |m:apply[*[1][self::m:csymbol=\'card\']]"><mrow><mo>|</mo><x:apply-templates select="*[2]"/><mo>|</mo></mrow></x:template>  <x:template match="m:apply[*[1][self::m:cartesianproduct or self::m:vectorproduct]] |m:apply[*[1][self::m:csymbol[.=\'cartesian_product\' or . = \'vectorproduct\']]]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#215;</mo></x:with-param></x:call-template></x:template> <x:template match="m:apply[*[1][self::m:cartesianproduct][count(following-sibling::m:reals)=count(following-sibling::*)]]" priority="2"><msup><x:apply-templates select="*[2]"><x:with-param name="p" select="5"/></x:apply-templates><mn><x:value-of select="count(*)-1"/></mn></msup></x:template>   <x:template name="sum" match="m:apply[*[1][self::m:sum]]"><x:param name="mo"><mo>&#8721;</mo></x:param><mrow><munderover><x:copy-of select="$mo"/><mrow><x:apply-templates select="m:lowlimit|m:interval/*[1]|m:condition/*|m:domainofapplication/*"/></mrow><mrow><x:apply-templates select="m:uplimit/*|m:interval/*[2]"/></mrow></munderover><x:apply-templates select="*[last()]"/></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'sum\']]"><mrow><munder><mo>&#8721;</mo><x:apply-templates select="*[2]"/></munder><x:apply-templates select="*[last()]"/></mrow></x:template> <x:template match="m:apply/m:lowlimit" priority="3"><mrow><x:if test="../m:bvar"><x:apply-templates select="../m:bvar/node()"/><mo>=</mo></x:if><x:apply-templates/></mrow></x:template>  <x:template match="m:apply[*[1][self::m:product]]"><x:call-template name="sum"><x:with-param name="mo"><mo>&#8719;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:csymbol=\'product\']]"><mrow><munder><mo>&#8719;</mo><x:apply-templates select="*[2]"/></munder><x:apply-templates select="*[last()]"/></mrow></x:template>  <x:template match="m:apply[*[1][self::m:limit]]"><mrow><munder><mi>lim</mi><mrow><x:apply-templates select="m:lowlimit|m:condition/*"/></mrow></munder><x:apply-templates select="*[last()]"/></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'limit\']][m:bind]"><mrow><munder><mi>lim</mi><mrow><x:apply-templates select="m:bind/m:bvar/*"/><mo><x:choose><x:when test="*[3]=\'above\'">&#8600;</x:when><x:when test="*[3]=\'below\'">&#8599;</x:when><x:otherwise>&#8594;</x:otherwise></x:choose></mo><x:apply-templates select="*[2]"/></mrow></munder><x:apply-templates select="m:bind/*[last()]"/></mrow></x:template>   <x:template match="m:apply[m:limit]/m:lowlimit" priority="4"><mrow><x:apply-templates select="../m:bvar/node()"/><mo>&#8594;</mo><x:apply-templates/></mrow></x:template>   <x:template match="m:apply[*[1][self::m:tendsto]]|m:reln[*[1][self::m:tendsto]]"><x:param name="p"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo><x:choose><x:when test="@type=\'above\'">&#8600;</x:when><x:when test="@type=\'below\'">&#8599;</x:when><x:when test="@type=\'two-sided\'">&#8594;</x:when><x:otherwise>&#8594;</x:otherwise></x:choose></mo></x:with-param></x:call-template></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'tendsto\']]"><mrow><x:apply-templates select="*[3]"/><mo><x:choose><x:when test="*[1][self::above]">&#8600;</x:when><x:when test="*[1][self::below]">&#8599;</x:when><x:when test="*[1][self::two-sided]">&#8594;</x:when><x:otherwise>&#8594;</x:otherwise></x:choose></mo><x:apply-templates select="*[4]"/></mrow></x:template> <x:template match="m:apply[*[1][self::m:semantics/m:ci=\'tendsto\']]"><mrow><x:apply-templates select="*[2]"/><mo>&#8594;</mo><x:apply-templates select="*[3]"/></mrow></x:template> <x:template match="m:tendsto"><mi>tendsto</mi></x:template>  <x:template match="m:apply[*[1][ self::m:sin or self::m:cos or self::m:tan or self::m:sec or self::m:csc or self::m:cot or self::m:sinh or self::m:cosh or self::m:tanh or self::m:sech or self::m:csch or self::m:coth or self::m:arcsin or self::m:arccos or self::m:arctan or self::m:arccosh or self::m:arccot or self::m:arccoth or self::m:arccsc or self::m:arccsch or self::m:arcsec or self::m:arcsech or self::m:arcsinh or self::m:arctanh or self::m:ln]]"><mrow><mi><x:value-of select="local-name(*[1])"/></mi><mo>&#8289;</mo><x:if test="m:apply"><mo>(</mo></x:if><x:apply-templates select="*[2]"/><x:if test="m:apply"><mo>)</mo></x:if></mrow></x:template>  <x:template match=" m:sin | m:cos | m:tan | m:sec | m:csc | m:cot | m:sinh | m:cosh | m:tanh | m:sech | m:csch | m:coth | m:arcsin | m:arccos | m:arctan | m:arccosh | m:arccot | m:arccoth | m:arccsc | m:arccsch | m:arcsec | m:arcsech | m:arcsinh | m:arctanh | m:ln|m:mean| m:plus|m:minus"><mi><x:value-of select="local-name()"/></mi></x:template>     <x:template match="m:apply[*[1][self::m:exp]] |m:apply[*[1][self::m:csymbol=\'exp\']]"><msup><mi>e</mi><mrow><x:apply-templates select="*[2]"/></mrow></msup></x:template>     <x:template match="m:apply[*[1][self::m:log]] |m:apply[*[1][self::m:csymbol=\'log\']]"><mrow><x:choose><x:when test="not(m:logbase) or m:logbase=10"><mi>log</mi></x:when><x:otherwise><msub><mi>log</mi><mrow><x:apply-templates select="m:logbase/node()"/></mrow></msub></x:otherwise></x:choose><mo>&#8289;</mo><x:apply-templates select="*[last()]"><x:with-param name="p" select="7"/></x:apply-templates></mrow></x:template>   <x:template match="m:apply[*[1][self::m:mean]] |m:apply[*[1][self::m:csymbol=\'mean\']]"><mrow><mo>&#9001;</mo><x:for-each select="*[position()&gt;1]"><x:apply-templates select="."/><x:if test="position() !=last()"><mo>,</mo></x:if></x:for-each><mo>&#9002;</mo></mrow></x:template>   <x:template match="m:sdev|m:csymbol[.=\'sdev\']"><mo>&#963;</mo></x:template>  <x:template match="m:apply[*[1][self::m:variance]] |m:apply[*[1][self::m:csymbol=\'variance\']]"><msup><mrow><mo>&#963;</mo><mo>&#8289;</mo><mfenced><x:apply-templates select="*[position()!=1]"/></mfenced></mrow><mn>2</mn></msup></x:template>   <x:template match="m:median"><mi>median</mi></x:template>   <x:template match="m:mode"><mi>mode</mi></x:template>  <x:template match="m:apply[*[1][self::m:moment]]"><mrow><mo>&#9001;</mo><msup><x:variable name="data" select="*[not(position()=1)] [not(self::m:degree or self::m:momentabout)]"/><x:choose><x:when test="$data[2]"><mfenced><x:apply-templates select="$data"/></mfenced></x:when><x:otherwise><x:apply-templates select="$data"/></x:otherwise></x:choose><mrow><x:apply-templates select="m:degree/node()"/></mrow></msup><mo>&#9002;</mo></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'moment\']]"><msub><mrow><mo>&#9001;</mo><msup><x:apply-templates select="*[4]"/><x:apply-templates select="*[2]"/></msup><mo>&#9002;</mo></mrow><x:apply-templates select="*[3]"/></msub></x:template>  <x:template match="m:momentabout"/> <x:template match="m:apply[*[1][self::m:moment]][m:momentabout]" priority="2"><msub><mrow><mo>&#9001;</mo><msup><x:variable name="data" select="*[not(position()=1)] [not(self::m:degree or self::m:momentabout)]"/><x:choose><x:when test="$data[2]"><mfenced><x:apply-templates select="$data"/></mfenced></x:when><x:otherwise><x:apply-templates select="$data"/></x:otherwise></x:choose><mrow><x:apply-templates select="m:degree/node()"/></mrow></msup><mo>&#9002;</mo></mrow><mrow><x:apply-templates select="m:momentabout/*"/></mrow></msub></x:template>  <x:template match="m:vector"><mrow><mo>(</mo><mtable><x:for-each select="*"><mtr><mtd><x:apply-templates select="."/></mtd></mtr></x:for-each></mtable><mo>)</mo></mrow></x:template>  <x:template match="m:vector[m:condition]"><mrow><mo>[</mo><x:apply-templates select="*[last()]"/><mo>|</mo><x:apply-templates select="m:condition"/><mo>]</mo></mrow></x:template> <x:template match="m:vector[m:domainofapplication]"><mrow><mo>[</mo><x:apply-templates select="*[last()]"/><mo>|</mo><x:apply-templates select="m:bvar/*"/><mo>&#x2208;</mo><x:apply-templates select="m:domainofapplication/*"/><mo>]</mo></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'vector\']]"><mrow><mo>(</mo><mtable><x:for-each select="*[position()!=1]"><mtr><mtd><x:apply-templates select="."/></mtd></mtr></x:for-each></mtable><mo>)</mo></mrow></x:template>  <x:template match="m:matrix"><mrow><mo>(</mo><mtable><x:apply-templates/></mtable><mo>)</mo></mrow></x:template> <x:template match="m:matrix[m:condition]"><mrow><mo>[</mo><msub><mi>m</mi><mrow><x:for-each select="m:bvar"><x:apply-templates/><x:if test="position()!=last()"><mo>,</mo></x:if></x:for-each></mrow></msub><mo>|</mo><mrow><msub><mi>m</mi><mrow><x:for-each select="m:bvar"><x:apply-templates/><x:if test="position()!=last()"><mo>,</mo></x:if></x:for-each></mrow></msub><mo>=</mo><x:apply-templates select="*[last()]"/></mrow><mo>;</mo><x:apply-templates select="m:condition"/><mo>]</mo></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'matrix\']]"><mrow><mo>(</mo><mtable><x:apply-templates select="*[position()!=1]"/></mtable><mo>)</mo></mrow></x:template>   <x:template match="m:matrix/m:matrixrow"><mtr><x:for-each select="*"><mtd><x:apply-templates select="."/></mtd></x:for-each></mtr></x:template> <x:template match="m:matrixrow"><mtable><mtr><x:for-each select="*"><mtd><x:apply-templates select="."/></mtd></x:for-each></mtr></mtable></x:template> <x:template match="m:apply[*[1][self::m:csymbol.=\'matrixrow\']]"><mtr><x:for-each select="*[position()!=1]"><mtd><x:apply-templates select="."/></mtd></x:for-each></mtr></x:template>  <x:template match="m:apply[*[1][self::m:determinant]] |m:apply[*[1][self::m:csymbol=\'determinant\']]"><mrow><mi>det</mi><mo>&#8289;</mo><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates></mrow></x:template> <x:template match="m:apply[*[1][self::m:determinant]][*[2][self::m:matrix]]" priority="2"><mrow><mo>|</mo><mtable><x:apply-templates select="m:matrix/*"/></mtable><mo>|</mo></mrow></x:template>  <x:template match="m:apply[*[1][self::m:transpose]] |m:apply[*[1][self::m:csymbol=\'transpose\']]"><msup><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates><mi>T</mi></msup></x:template>  <x:template match="m:apply[*[1][self::m:selector]] |m:apply[*[1][self::m:csymbol=\'selector\']]"><msub><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates><mrow><x:for-each select="*[position()&gt;2]"><x:apply-templates select="."/><x:if test="position() !=last()"><mo>,</mo></x:if></x:for-each></mrow></msub></x:template>      <x:template match="m:apply[*[1][self::m:scalarproduct]] |m:apply[*[1][self::m:csymbol=\'scalarproduct\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>.</mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:outerproduct]] |m:apply[*[1][self::m:csymbol=\'outerproduct\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#x2297;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:semantics"><x:apply-templates select="*[1]"/></x:template><x:template match="m:semantics[m:annotation-xml/@encoding=\'MathML-Presentation\']"><x:apply-templates select="m:annotation-xml[@encoding=\'MathML-Presentation\']/node()"/></x:template>  <x:template match="m:integers"><mi mathvariant="double-struck">Z</mi></x:template>  <x:template match="m:reals"><mi mathvariant="double-struck">R</mi></x:template>  <x:template match="m:rationals"><mi mathvariant="double-struck">Q</mi></x:template>  <x:template match="m:naturalnumbers"><mi mathvariant="double-struck">N</mi></x:template>  <x:template match="m:complexes"><mi mathvariant="double-struck">C</mi></x:template>  <x:template match="m:primes"><mi mathvariant="double-struck">P</mi></x:template>  <x:template match="m:exponentiale"><mi>e</mi></x:template>  <x:template match="m:imaginaryi"><mi>i</mi></x:template>  <x:template match="m:notanumber"><mi>NaN</mi></x:template>  <x:template match="m:true"><mi>true</mi></x:template>  <x:template match="m:false"><mi>false</mi></x:template>  <x:template match="m:emptyset|m:csymbol[.=\'emptyset\']"><mi>&#8709;</mi></x:template>   <x:template match="m:pi|m:csymbol[.=\'pi\']"><mi>&#960;</mi></x:template>  <x:template match="m:eulergamma|m:csymbol[.=\'gamma\']"><mi>&#947;</mi></x:template>  <x:template match="m:infinity|m:csymbol[.=\'infinity\']"><mi>&#8734;</mi></x:template>   <x:template name="infix" ><x:param name="mo"/><x:param name="p" select="0"/><x:param name="this-p" select="0"/><x:variable name="dmo"><x:choose><x:when test="m:domainofapplication"><munder><x:copy-of select="$mo"/><mrow><x:apply-templates select="m:domainofapplication/*"/></mrow></munder></x:when><x:otherwise><x:copy-of select="$mo"/></x:otherwise></x:choose></x:variable><mrow><x:if test="$this-p &lt; $p"><mo>(</mo></x:if><x:for-each select="*[not(self::m:domainofapplication)][position()&gt;1]"><x:if test="position() &gt; 1"><x:copy-of select="$dmo"/></x:if><x:apply-templates select="."><x:with-param name="p" select="$this-p"/></x:apply-templates></x:for-each><x:if test="$this-p &lt; $p"><mo>)</mo></x:if></mrow></x:template> <!-- make 1-(9-2) google code isse 3--><x:template name="binary" ><x:param name="mo"/><x:param name="p" select="0"/><x:param name="this-p" select="0"/><mrow><x:if test="($this-p &lt; $p) or ($this-p=$p and $mo=\'&#8722;\')"><mo>(</mo></x:if><x:apply-templates select="*[2]"><x:with-param name="p" select="$this-p"/></x:apply-templates><x:copy-of select="$mo"/><x:apply-templates select="*[3]"><x:with-param name="p" select="$this-p"/></x:apply-templates><x:if test="($this-p &lt; $p) or ($this-p=$p and $mo=\'&#8722;\')"><mo>)</mo></x:if></mrow></x:template> <x:template name="set" ><x:param name="o" select="\'{\'"/><x:param name="c" select="\'}\'"/><mrow><mo><x:value-of select="$o"/></mo><x:choose><x:when test="m:condition"><mrow><x:apply-templates select="m:condition/following-sibling::*"/></mrow><mo>|</mo><mrow><x:apply-templates select="m:condition/node()"/></mrow></x:when><x:when test="m:domainofapplication"><mrow><x:apply-templates select="m:domainofapplication/following-sibling::*"/></mrow><mo>|</mo><mrow><x:apply-templates select="m:bvar/node()"/></mrow><mo>&#8712;</mo><mrow><x:apply-templates select="m:domainofapplication/node()"/></mrow></x:when><x:otherwise><x:for-each select="*[not(position()=1 and parent::m:apply)]"><x:apply-templates select="."/><x:if test="position() !=last()"><mo>,</mo></x:if></x:for-each></x:otherwise></x:choose><mo><x:value-of select="$c"/></mo></mrow></x:template>    <x:template match="m:cs"><ms><x:value-of select=" translate(., \'&#9;&#10;&#13;&#32;\', \'&#160;&#160;&#160;&#160;\')"/></ms></x:template> <x:template match="m:cbytes"><mrow/></x:template> <x:template match="m:cerror"><merror><x:apply-templates/></merror></x:template> <x:template match="m:share" priority="4"><mi href="{@href}">share<x:value-of select="substring-after(@href,\'#\')"/></mi></x:template>  </x:stylesheet>';var d;if(window.XSLTProcessor){if(!c.ParseXML){c.ParseXML=c.createParser()}c.ctopXSLT=new XSLTProcessor();c.ctopXSLT.importStylesheet(c.ParseXML(a))}else{if(MathJax.Hub.Browser.isMSIE){if(MathJax.Hub.Browser.versionAtLeast("9.0")){d=new ActiveXObject("Msxml2.FreeThreadedDOMDocument");d.loadXML(a);var b=new ActiveXObject("Msxml2.XSLTemplate");b.stylesheet=d;c.ctopXSLT={ctop:b.createProcessor(),transformToDocument:function(f){this.ctop.input=f;this.ctop.transform();return this.ctop.output}}}else{d=c.createMSParser();d.async=false;d.loadXML(a);c.ctopXSLT={ctop:d,transformToDocument:function(f){return f.documentElement.transformNode(this.ctop)}}}}else{c.ctopXSLT=null}}MathJax.Hub.Startup.signal.Post("MathML content-mathml Ready")});MathJax.Ajax.loadComplete("[MathJax]/extensions/MathML/content-mathml.js");
